---
layout: single
title:  "데이터분석 5장 판다스"
categories: coding
tag: [python, blog, jekyll]
toc: true
author_profile: false
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>



```python
# 5.3.1 229쪽부터 복습
```

# 5장 Pandas 시작하기


- pandas와 Numpy의 가장 큰 차이점<br>

pandas는 표 형식의 데이터나 다양한 형태의 데이터를 다루는 데 초점을 맞춰 설계함<br>

NumPy는 단일 산술 배열 데이터를 다루는 데 특화되어 있음



```python
import pandas as pd
```

## 5.1 pandas 자료구조 소개


pandas에 대해 알아보려면 Series와 DataFrame, 이 두 가지 자료구조에 익숙해질 필요가 있음


### 5.1.1 Series


Series는 일련의 객체를 담을 수 있는 1차원 배열 같은 자료구조(어떤 NumPy 자료형이라도 담을 수 있음)<br>

그리고 ***색인***(index)이라고 하는 배열의 데이터와 연관된 이름을 가지고 있음<br>

가장 간단한 Series 객체는 배열 데이터로부터 생성 가능



```python
obj = pd.Series([4,7,-5,3])
```


```python
obj
```

<pre>
0    4
1    7
2   -5
3    3
dtype: int64
</pre>
Series 객체의 문자열 표현

- 왼쪽 : 색인

- 오른쪽 : 해당 색인의 값


위 예제에서는 데이터의 색인을 지정하지 않았으니 기본 색인인 정수 0에서 N - 1(N은 데이터의 길이)까지의 숫자가 표시됨<br>


#### values, index

Series의 배열과 색인 객체는 각각 values와 index 속성을 통해 얻을 수 있음



```python
obj.values
```

<pre>
array([ 4,  7, -5,  3], dtype=int64)
</pre>

```python
obj.index #range(4)와 같다
```

<pre>
RangeIndex(start=0, stop=4, step=1)
</pre>
각각의 데이터를 지칭하는 색인을 지정하여 Series 객체를 생성해야 할 때는 다음처럼 함



```python
obj2 = pd.Series([4,7,-5,3], index=['d', 'b', 'a', 'c'])
```


```python
obj2
```

<pre>
d    4
b    7
a   -5
c    3
dtype: int64
</pre>

```python
obj2.index
```

<pre>
Index(['d', 'b', 'a', 'c'], dtype='object')
</pre>
NumPy 배열과 비교하자면, 단일 값을 선택하거나 여러 값을 선택할 때 색인으로 라벨 사용가능



```python
obj2['a']
```

<pre>
-5
</pre>

```python
obj2['d'] = 6
```


```python
obj2
```

<pre>
d    6
b    7
a   -5
c    3
dtype: int64
</pre>

```python
obj2[['c', 'a', 'd']]
```

<pre>
c    3
a   -5
d    6
dtype: int64
</pre>
여기서 ['c', 'a', 'd']는 (정수가 아니라 문자열이 포함되어 있지만) 색인의 배열로 해석됨


불리언 배열을 사용해 값을 걸러내거나 산술 곱셈을 수행하거나 또는 수학 함수를 적용하는 등<br>

NumPy 배열 연산을 수행해도 색인-값 연결이 유지된다



```python
obj2[obj2>0]
```

<pre>
d    6
b    7
c    3
dtype: int64
</pre>

```python
obj2*2
```

<pre>
d    12
b    14
a   -10
c     6
dtype: int64
</pre>

```python
np.exp(obj2)
```

<pre>
d     403.428793
b    1096.633158
a       0.006738
c      20.085537
dtype: float64
</pre>
Series를 이해하는 다른 방법은 고정 길이의 정렬된 사전형이라고 생각하는 것<br>

Series는 색인값에 데이터값을 매핑하고 있으므로 파이썬의 사전형과 비슷<br>

Series 객체는 파이썬의 사전형을 인자로 받아야 하는 많은 함수에서 사전형을 대체해 사용 가능



```python
'b' in obj2
```

<pre>
True
</pre>

```python
'e' in obj2
```

<pre>
False
</pre>
파이썬 사전형에 데이터를 저장해야 한다면 파이썬 객체로부터 Series 객체 생성 가능



```python
sdata = {'Ohio': 35000, 'Texas': 71000, 'Oregon': 16000, 'Utah': 5000}
```


```python
obj3 = pd.Series(sdata)
```


```python
obj3
```

<pre>
Ohio      35000
Texas     71000
Oregon    16000
Utah       5000
dtype: int64
</pre>
사전 객체만 가지고 Series 객체를 생성하면 생성된 Series 객체의 색인에는 사전의 키값이 순서대로 들어감<br>

색인을 직접 지정하고 싶다면 원하는 순서대로 색인을 직접 넘겨줄 수도 있음



```python
states = ['California', 'Ohio', 'Oregon', 'Texas']
```


```python
obj4 = pd.Series(sdata, index=states)
```


```python
obj4
```

<pre>
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64
</pre>
이 예제를 보면 sdata에 있는 값 중 3개만 확인 가능<br>

이는 'California'에 대한 값은 찾을 수 없기 때문<br>

이 값은 NaN(not a number)로 표시되고 pandas에선느 누락된 값, 혹은 NA 값으로 취급됨<br>

'Utah'는 states에 포함되어 있지 않으므로 실행 결과에서 빠짐


#### isnull, notnull


pandas의 isnull과 notnull 함수는 누락된 데이터를 찾을 때 사용됨



```python
pd.isnull(obj4)
```

<pre>
California     True
Ohio          False
Oregon        False
Texas         False
dtype: bool
</pre>

```python
pd.notnull(obj4)
```

<pre>
California    False
Ohio           True
Oregon         True
Texas          True
dtype: bool
</pre>
이 메서드는 Series의 인스턴스 메서드로도 존재



```python
obj4.isnull()
```

<pre>
California     True
Ohio          False
Oregon        False
Texas         False
dtype: bool
</pre>
Series의 유용한 기능은 산술 연산에서 색인과 라벨로 자동 정렬하는 것



```python
obj3
```

<pre>
Ohio      35000
Texas     71000
Oregon    16000
Utah       5000
dtype: int64
</pre>

```python
obj4
```

<pre>
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64
</pre>

```python
obj3 + obj4
```

<pre>
California         NaN
Ohio           70000.0
Oregon         32000.0
Texas         142000.0
Utah               NaN
dtype: float64
</pre>
Series 객체와 Series의 색인은 모두 name 속성이 있는데 이 속성은 pandas의 핵심 기능과 밀접한 관련이 있음



```python
obj4.name = 'population'
```


```python
obj4.index.name = 'state'
```


```python
obj4
```

<pre>
state
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
Name: population, dtype: float64
</pre>
Series의 색인은 대입하여 변경 가능



```python
obj = pd.Series([4,7,-5,3])
obj
```

<pre>
0    4
1    7
2   -5
3    3
dtype: int64
</pre>

```python
obj.index = ['Bob', 'Steve', 'jeff', 'Ryan']
```


```python
obj
```

<pre>
Bob      4
Steve    7
jeff    -5
Ryan     3
dtype: int64
</pre>
### 5.1.2 DataFrame


Dataframe은 표 같은 스프레드시트 형식의 자료구조<br>

Dataframe에는 여러 개의 컬럼이 있는데 각 컬럼은 서로 다른 종류의 값(숫자, 문자열, 불리언 등)을 담을 수 있음<br>

Dataframe은 로우와 컬럼에 대한 색인을 가지고 있는데, 색인의 모양이 같은 Series 객체를 담고 있는 파이썬 사전을 생각하면 편함<br>

내부적으로 데이터는 리스트나 사전 또는 1차원 배열을 담고 있는 다른 컬렉션이 아니라 하나 이상의 2차원 배열에 저장됨


DataFrame 객체를 생성하는 방법

- 같은 길이의 리스트에 담긴 사전을 이용

- Numpy 배열을 이용



```python
data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
       'year': [2000, 2001, 2002, 2001, 2002, 2003],
       'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}
```


```python
frame = pd.DataFrame(data)
```

만들어진 DataFrame의 색인은 Series와 같은 방식으로 자동으로 대입되며 컬럼은 정렬되어 저장됨



```python
frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>state</th>
      <th>year</th>
      <th>pop</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Ohio</td>
      <td>2000</td>
      <td>1.5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Ohio</td>
      <td>2001</td>
      <td>1.7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Ohio</td>
      <td>2002</td>
      <td>3.6</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Nevada</td>
      <td>2001</td>
      <td>2.4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Nevada</td>
      <td>2002</td>
      <td>2.9</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Nevada</td>
      <td>2003</td>
      <td>3.2</td>
    </tr>
  </tbody>
</table>
</div>


큰 DataFrame을 다룰 때는 head 메서드를 이용해 처음 5개의 로우만 출력가능



```python
frame.head()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>state</th>
      <th>year</th>
      <th>pop</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Ohio</td>
      <td>2000</td>
      <td>1.5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Ohio</td>
      <td>2001</td>
      <td>1.7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Ohio</td>
      <td>2002</td>
      <td>3.6</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Nevada</td>
      <td>2001</td>
      <td>2.4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Nevada</td>
      <td>2002</td>
      <td>2.9</td>
    </tr>
  </tbody>
</table>
</div>


원하는 순서대로 columns를 지정하면 원하는 순서를 가진 DataFrame 객체가 생성됨



```python
pd.DataFrame(data, columns=['year', 'state', 'pop'])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>year</th>
      <th>state</th>
      <th>pop</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2000</td>
      <td>Ohio</td>
      <td>1.5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2001</td>
      <td>Ohio</td>
      <td>1.7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2002</td>
      <td>Ohio</td>
      <td>3.6</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2001</td>
      <td>Nevada</td>
      <td>2.4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2002</td>
      <td>Nevada</td>
      <td>2.9</td>
    </tr>
    <tr>
      <th>5</th>
      <td>2003</td>
      <td>Nevada</td>
      <td>3.2</td>
    </tr>
  </tbody>
</table>
</div>


Series와 마찬가지로 사전에 없는 값을 넘기면 결측치로 저장



```python
data
```

<pre>
{'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
 'year': [2000, 2001, 2002, 2001, 2002, 2003],
 'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}
</pre>

```python
frame2 = pd.DataFrame(data, columns = ['year', 'state', 'pop', 'debt'],
                     index = ['one', 'two', 'three', 'four', 'five', 'six'])
```


```python
frame2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>year</th>
      <th>state</th>
      <th>pop</th>
      <th>debt</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>2000</td>
      <td>Ohio</td>
      <td>1.5</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>two</th>
      <td>2001</td>
      <td>Ohio</td>
      <td>1.7</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>three</th>
      <td>2002</td>
      <td>Ohio</td>
      <td>3.6</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>four</th>
      <td>2001</td>
      <td>Nevada</td>
      <td>2.4</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>five</th>
      <td>2002</td>
      <td>Nevada</td>
      <td>2.9</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>six</th>
      <td>2003</td>
      <td>Nevada</td>
      <td>3.2</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame2.columns
```

<pre>
Index(['year', 'state', 'pop', 'debt'], dtype='object')
</pre>
DataFrame의 컬럼은 Series처럼 사전 형식의 표기법으로 접근하거나 속성 형식으로 접근 가능



```python
frame2['state']
```

<pre>
one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
six      Nevada
Name: state, dtype: object
</pre>

```python
frame2.year
```

<pre>
one      2000
two      2001
three    2002
four     2001
five     2002
six      2003
Name: year, dtype: int64
</pre>
***NOTE_*** frame2[column] 형태로 사용하는 것은 어떤 칼럼이든 가능하지만 <br>

frame2.column 형태로 사용하는 것은 사용 가능한 변수 이름 형식일 때만 작동


#### loc


반환된 Series 객체가 DataFrame과 같은 색인을 가지면 알맞은 값으로 name 속성이 채워짐<br>

로우는 위치나 loc 속성을 이용해 이름을 통해 접근 가능



```python
frame2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>year</th>
      <th>state</th>
      <th>pop</th>
      <th>debt</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>2000</td>
      <td>Ohio</td>
      <td>1.5</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>two</th>
      <td>2001</td>
      <td>Ohio</td>
      <td>1.7</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>three</th>
      <td>2002</td>
      <td>Ohio</td>
      <td>3.6</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>four</th>
      <td>2001</td>
      <td>Nevada</td>
      <td>2.4</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>five</th>
      <td>2002</td>
      <td>Nevada</td>
      <td>2.9</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>six</th>
      <td>2003</td>
      <td>Nevada</td>
      <td>3.2</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame2.loc['three']
```

<pre>
year     2002
state    Ohio
pop       3.6
debt      NaN
Name: three, dtype: object
</pre>
컬럼은 대입 가능<br>

예를 들어 현재 비어 있는 'debt' 컬럼에 스칼라값이나 배열의 값 대입 가능



```python
frame2['debt'] = 16.5
```


```python
frame2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>year</th>
      <th>state</th>
      <th>pop</th>
      <th>debt</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>2000</td>
      <td>Ohio</td>
      <td>1.5</td>
      <td>16.5</td>
    </tr>
    <tr>
      <th>two</th>
      <td>2001</td>
      <td>Ohio</td>
      <td>1.7</td>
      <td>16.5</td>
    </tr>
    <tr>
      <th>three</th>
      <td>2002</td>
      <td>Ohio</td>
      <td>3.6</td>
      <td>16.5</td>
    </tr>
    <tr>
      <th>four</th>
      <td>2001</td>
      <td>Nevada</td>
      <td>2.4</td>
      <td>16.5</td>
    </tr>
    <tr>
      <th>five</th>
      <td>2002</td>
      <td>Nevada</td>
      <td>2.9</td>
      <td>16.5</td>
    </tr>
    <tr>
      <th>six</th>
      <td>2003</td>
      <td>Nevada</td>
      <td>3.2</td>
      <td>16.5</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame2['debt'] = np.arange(6.)
```


```python
frame2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>year</th>
      <th>state</th>
      <th>pop</th>
      <th>debt</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>2000</td>
      <td>Ohio</td>
      <td>1.5</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>two</th>
      <td>2001</td>
      <td>Ohio</td>
      <td>1.7</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>three</th>
      <td>2002</td>
      <td>Ohio</td>
      <td>3.6</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>four</th>
      <td>2001</td>
      <td>Nevada</td>
      <td>2.4</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>five</th>
      <td>2002</td>
      <td>Nevada</td>
      <td>2.9</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>six</th>
      <td>2003</td>
      <td>Nevada</td>
      <td>3.2</td>
      <td>5.0</td>
    </tr>
  </tbody>
</table>
</div>


리스트나 배열을 컬럼에 대입할 때는 대입하려는 값의 길이가 DataFrame의 크기와 동일해야 함<br>

Series를 대입하면 DataFrame의 색인에 따라 값이 대입되며 존재하지 않는 색인에는 결측치가 대입



```python
val = pd.Series([-1.2, -1.5, -1.7], index=['two', 'four', 'five'])
```


```python
frame2['debt'] = val
```


```python
frame2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>year</th>
      <th>state</th>
      <th>pop</th>
      <th>debt</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>2000</td>
      <td>Ohio</td>
      <td>1.5</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>two</th>
      <td>2001</td>
      <td>Ohio</td>
      <td>1.7</td>
      <td>-1.2</td>
    </tr>
    <tr>
      <th>three</th>
      <td>2002</td>
      <td>Ohio</td>
      <td>3.6</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>four</th>
      <td>2001</td>
      <td>Nevada</td>
      <td>2.4</td>
      <td>-1.5</td>
    </tr>
    <tr>
      <th>five</th>
      <td>2002</td>
      <td>Nevada</td>
      <td>2.9</td>
      <td>-1.7</td>
    </tr>
    <tr>
      <th>six</th>
      <td>2003</td>
      <td>Nevada</td>
      <td>3.2</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>


존재하지 않는 컬럼을 대입하면 새로운 컬럼을 생성<br>

파이썬 사전형에서처럼 del 예약어를 사용해 컬럼 삭제 가능


del 예약어에 대한 예제로, state 컬럼의 값이 'Ohio'인지 아닌지에 대한 불리언값을 담고 있는 새로운 컬럼 생성



```python
frame2['eastern'] = frame2.state == 'Ohio'
```


```python
frame2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>year</th>
      <th>state</th>
      <th>pop</th>
      <th>debt</th>
      <th>eastern</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>2000</td>
      <td>Ohio</td>
      <td>1.5</td>
      <td>NaN</td>
      <td>True</td>
    </tr>
    <tr>
      <th>two</th>
      <td>2001</td>
      <td>Ohio</td>
      <td>1.7</td>
      <td>-1.2</td>
      <td>True</td>
    </tr>
    <tr>
      <th>three</th>
      <td>2002</td>
      <td>Ohio</td>
      <td>3.6</td>
      <td>NaN</td>
      <td>True</td>
    </tr>
    <tr>
      <th>four</th>
      <td>2001</td>
      <td>Nevada</td>
      <td>2.4</td>
      <td>-1.5</td>
      <td>False</td>
    </tr>
    <tr>
      <th>five</th>
      <td>2002</td>
      <td>Nevada</td>
      <td>2.9</td>
      <td>-1.7</td>
      <td>False</td>
    </tr>
    <tr>
      <th>six</th>
      <td>2003</td>
      <td>Nevada</td>
      <td>3.2</td>
      <td>NaN</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>


***CAUTION_*** 이 새로운 컬럼은 frame2.eastern 형태의 문법으로는 생성되지 X


#### del


del 예약어를 이용해 이 컬럼 삭제 가능



```python
del frame2['eastern']
```


```python
frame2.columns
```

<pre>
Index(['year', 'state', 'pop', 'debt'], dtype='object')
</pre>
***CAUTION_*** DataFrame의 색인을 이용해서 얻은 컬럼은 내부 데이터에 대한 ***뷰***(view)이며 복사가 이루어지지 X<br>

따라서 이렇게 얻은 Series 객체에 대한 변경은 실제 DataFrame에 반영됨<br>

복사본이 필요할 때는 Series의 copy 메서드를 이용하자


중첩된 사전을 이용해 데이터 생성 가능



```python
pop = {'Nevada': {2001: 2.4, 2002: 2.9},
      'Ohio': {2000: 1.5, 2001: 1.7, 2002: 3.6}}
```

이 중첩된 사전을 DataFrame에 넘기면 바깥에 있는 사전의 키는 컬럼이 되고 안에 있는 키는 로우가 된다



```python
frame3 = pd.DataFrame(pop)
```


```python
frame3
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Nevada</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2001</th>
      <td>2.4</td>
      <td>1.7</td>
    </tr>
    <tr>
      <th>2002</th>
      <td>2.9</td>
      <td>3.6</td>
    </tr>
    <tr>
      <th>2000</th>
      <td>NaN</td>
      <td>1.5</td>
    </tr>
  </tbody>
</table>
</div>


NumPy 배열과 유사한 문법으로 데이터를 전치(컬럼과 로우를 뒤집음)할 수 있음



```python
frame3.T
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>2001</th>
      <th>2002</th>
      <th>2000</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Nevada</th>
      <td>2.4</td>
      <td>2.9</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>1.7</td>
      <td>3.6</td>
      <td>1.5</td>
    </tr>
  </tbody>
</table>
</div>


중첩된 사전을 이용해 DataFrame을 생성할 때 안쪽에 있는 사전값은 키값별로 조합되어 결과의 색인이 되지만<bR>

색인을 직접 지정하면 지정된 색인으로 DataFrame을 생성



```python
pd.DataFrame(pop, index = [2001,2002,2003])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Nevada</th>
      <th>Ohio</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2001</th>
      <td>2.4</td>
      <td>1.7</td>
    </tr>
    <tr>
      <th>2002</th>
      <td>2.9</td>
      <td>3.6</td>
    </tr>
    <tr>
      <th>2003</th>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>


Series 객체를 담고 있는 사전 데이터도 같은 방식으로 취급



```python
pdata = {'Ohio': frame3['Ohio'][:-1],
        'Nevada': frame3['Nevada'][:2]}
```


```python
pd.DataFrame(pdata)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ohio</th>
      <th>Nevada</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2001</th>
      <td>1.7</td>
      <td>2.4</td>
    </tr>
    <tr>
      <th>2002</th>
      <td>3.6</td>
      <td>2.9</td>
    </tr>
  </tbody>
</table>
</div>


#### index.name, columns.name


만일 데이터프레임의 색인(index)과 컬럼(columns)에 name 속성을 지정했다면 이 역시 함께 출력



```python
frame3.index.name = 'year'; frame3.columns.name = 'state'
```


```python
frame3
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>state</th>
      <th>Nevada</th>
      <th>Ohio</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2001</th>
      <td>2.4</td>
      <td>1.7</td>
    </tr>
    <tr>
      <th>2002</th>
      <td>2.9</td>
      <td>3.6</td>
    </tr>
    <tr>
      <th>2000</th>
      <td>NaN</td>
      <td>1.5</td>
    </tr>
  </tbody>
</table>
</div>


#### values


Series와 유사하게 values 속성은 DataFrame에 저장된 데이터를 2차원 배열로 반환



```python
frame3.values
```

<pre>
array([[2.4, 1.7],
       [2.9, 3.6],
       [nan, 1.5]])
</pre>
DataFrame의 컬럼이 서로 다른 dtype을 가지고 있다면 모든 컬럼을 수용하기 위해 그 컬럼의 배열의 dtype이 선택됨



```python
frame2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>year</th>
      <th>state</th>
      <th>pop</th>
      <th>debt</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>2000</td>
      <td>Ohio</td>
      <td>1.5</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>two</th>
      <td>2001</td>
      <td>Ohio</td>
      <td>1.7</td>
      <td>-1.2</td>
    </tr>
    <tr>
      <th>three</th>
      <td>2002</td>
      <td>Ohio</td>
      <td>3.6</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>four</th>
      <td>2001</td>
      <td>Nevada</td>
      <td>2.4</td>
      <td>-1.5</td>
    </tr>
    <tr>
      <th>five</th>
      <td>2002</td>
      <td>Nevada</td>
      <td>2.9</td>
      <td>-1.7</td>
    </tr>
    <tr>
      <th>six</th>
      <td>2003</td>
      <td>Nevada</td>
      <td>3.2</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame2.values
```

<pre>
array([[2000, 'Ohio', 1.5, nan],
       [2001, 'Ohio', 1.7, -1.2],
       [2002, 'Ohio', 3.6, nan],
       [2001, 'Nevada', 2.4, -1.5],
       [2002, 'Nevada', 2.9, -1.7],
       [2003, 'Nevada', 3.2, nan]], dtype=object)
</pre>
#### DataFrame 생성을 위한 입력 데이터의 종류


|형|설명|

|---|---|

|2차원 ndarray|데이터를 담고 있는 행렬. 선택적으로 행(로우)과 열(컬럼)의 이름을 전달 가능|

|배열, 리스트, 튜플의 사전|사전의 모든 항목은 같은 길이를 가져야 하며, 각 항목의 내용이 DataFrame의 컬럼이 됨|

|NumPy의 구조화 배열|배열의 사전과 같은 방식으로 취급됨|

|Series의 사전|Series의 각 값이 컬럼이 된다. 명시적으로 색인을 넘겨주지 않으면 각 Series의 색인이 하나로 합쳐져서 로우의 색인이 됨|

|사전의 사전|내부에 있는 사전이 컬럼이 됨. 키값은 'Series의 사전'과 마찬가지로 합쳐져서 로우의 색인이 됨|

|사전이나 Series의 리스트| 리스트의 각 항목이 DataFrame의 로우가 된다. 합쳐진 사전의 키값이나 Series의 색인이 DataFrame의 컬럼 이름이 됨|

|리스트나 튜플의 리스트|'2차원 ndarray'의 경우와 같은 방식으로 취급|

|다른 DataFrame|색인을 따로 지정하지 않으면 DataFrame의 색인이 그대로 사용됨|

|NumPy MaskedArray|'2차원 ndarray'의 경우와 같은 방식으로 취급되지만 마스크값은 반환되는 DataFrame에서 NA 값이 됨|


### 5.1.3 색인 객체


#### index


pandas의 색인 객체 : 표 형식의 데이터에서 각 로우와 컬럼에 대한 이름과 다른 메타데이터(축의 이름 등)를 저장하는 객체<br>

Series나 DataFrame 객체를 생성할 때 사용되는 배열이나 다른 순차적인 이름은 내부적으로 색인이 변환됨



```python
obj = pd.Series(range(3), index=['a', 'b', 'c'])
```


```python
obj
```

<pre>
a    0
b    1
c    2
dtype: int64
</pre>

```python
index = obj.index
```


```python
index
```

<pre>
Index(['a', 'b', 'c'], dtype='object')
</pre>

```python
index[1:]
```

<pre>
Index(['b', 'c'], dtype='object')
</pre>
색인 객체는 변경이 불가능



```python
index[1] = 'd' # TypeError 발생
```

그러므로 자료구조 사이에서 안전하게 공유 가능



```python
labels = pd.Index(np.arange(3))
```


```python
labels
```

<pre>
Int64Index([0, 1, 2], dtype='int64')
</pre>

```python
obj2 = pd.Series([1.5, -2.5, 0], index=labels)
```


```python
obj2
```

<pre>
0    1.5
1   -2.5
2    0.0
dtype: float64
</pre>

```python
obj2.index is labels
```

<pre>
True
</pre>
또한 배열과 유사하게 Index 객체도 고정 크기로 동작



```python
frame3
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>state</th>
      <th>Nevada</th>
      <th>Ohio</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2001</th>
      <td>2.4</td>
      <td>1.7</td>
    </tr>
    <tr>
      <th>2002</th>
      <td>2.9</td>
      <td>3.6</td>
    </tr>
    <tr>
      <th>2000</th>
      <td>NaN</td>
      <td>1.5</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame3.columns
```

<pre>
Index(['Nevada', 'Ohio'], dtype='object', name='state')
</pre>

```python
'Ohio' in frame3.columns
```

<pre>
True
</pre>

```python
2003 in frame3.index
```

<pre>
False
</pre>
파이썬의 집합과는 달리 pandas의 인덱스는 중복되는 값을 허용



```python
dup_labels = pd.Index(['foo', 'foo', 'bar', 'bar'])
```


```python
dup_labels
```

<pre>
Index(['foo', 'foo', 'bar', 'bar'], dtype='object')
</pre>
중복되는 값으로 선택을 하면 해당 값을 가진 모든 항목이 선택됨


각각의 색인은 자신이 담고 있는 데이터에 대한 정보를 취급하기 위한 여러 메서드와 속성을 가지고 있다.


- 색인 메서드와 속성

https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.insert.html#pandas-dataframe-insert


#### append


추가적인 색인 객체를 덧붙여 새로운 색인을 반환


먼저, 아래와 같이 간단한 2x2 객체를 만든다



```python
df = pd.DataFrame(data=[[1,2],[3,4]], index=['row1', 'row2'], columns = ['col1', 'col3'] )
```


```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>col3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>row1</th>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>row2</th>
      <td>3</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>


먼저 간단한 df2를 만들어 append로 df와 합친다



```python
df2 = pd.DataFrame(data = [[5,6]], index=['row3'], columns = ['col2', 'col4'])
```


```python
df2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col2</th>
      <th>col4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>row3</th>
      <td>5</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.append(df2)
```

<pre>
C:\Users\user\AppData\Local\Temp\ipykernel_14280\2094904254.py:1: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.
  df.append(df2)
</pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>col3</th>
      <th>col2</th>
      <th>col4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>row1</th>
      <td>1.0</td>
      <td>2.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>row2</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>row3</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>5.0</td>
      <td>6.0</td>
    </tr>
  </tbody>
</table>
</div>


row3이 행추가 되었고 기존 df에는 없던 col2와 col4가 생성됨


#### difference

색인의 차집합 반환



```python
# pandas Series를 생성
s1 = pd.Series([1,2,3,4], index=['a', 'b', 'c', 'd'])
s2 = pd.Series([3,4,5,6], index=['c', 'd', 'e', 'f'])
```


```python
s1
```

<pre>
a    1
b    2
c    3
d    4
dtype: int64
</pre>

```python
s2
```

<pre>
c    3
d    4
e    5
f    6
dtype: int64
</pre>

```python
# difference 메서드 사용
difference = s1.index.difference(s2.index)
```


```python
difference
```

<pre>
Index(['a', 'b'], dtype='object')
</pre>
#### intersection


색인의 교집합 반환



```python
#Pandas Series 생성
s1 = pd.Series([1,2,3,4], index = ['a', 'b', 'c', 'd'])
s2 = pd.Series([3,4,5,6], index = ['c', 'd', 'e', 'f'])
```


```python
s1
```

<pre>
a    1
b    2
c    3
d    4
dtype: int64
</pre>

```python
s2
```

<pre>
c    3
d    4
e    5
f    6
dtype: int64
</pre>

```python
# intersection() 메서드 사용
intersection = s1.index.intersection(s2.index)
```


```python
intersection
```

<pre>
Index(['c', 'd'], dtype='object')
</pre>
#### union


색인의 합집합 반환



```python
#Pandas DataFrame 생성
df1 = pd.DataFrame({'A': [1,2,3], 'B':[4,5,6], 'C': [7,8,9]}, index = ['a', 'b', 'c'])
df2 = pd.DataFrame({'A': [3,4,5], 'B': [6,7,8], 'C': [9,10,11]}, index=['c', 'd', 'e'])
```


```python
df1
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1</td>
      <td>4</td>
      <td>7</td>
    </tr>
    <tr>
      <th>b</th>
      <td>2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th>c</th>
      <td>3</td>
      <td>6</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>



```python
df2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>c</th>
      <td>3</td>
      <td>6</td>
      <td>9</td>
    </tr>
    <tr>
      <th>d</th>
      <td>4</td>
      <td>7</td>
      <td>10</td>
    </tr>
    <tr>
      <th>e</th>
      <td>5</td>
      <td>8</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>



```python
union = df1.index.union(df2.index)
```


```python
union
```

<pre>
Index(['a', 'b', 'c', 'd', 'e'], dtype='object')
</pre>
#### isin


색인이 넘격받은 색인에 존재하는지 알려주는 불리언 배열 반환



```python
df = pd.DataFrame({'A': [1,2,3], 'B':['a', 'b', 'f']})
```


```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>a</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>b</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>f</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.isin([1,3,12,'a'])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>1</th>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>2</th>
      <td>True</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>


#### drop


넘겨받은 값이 삭제된 새로운 색인 반환



```python
df = pd.DataFrame(np.arange(12).reshape(3,4),
                 columns = ['A', 'B', 'C', 'D'])
```


```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>


열 삭제



```python
df.drop(['B', 'C'], axis = 1)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4</td>
      <td>7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.drop(columns = ['B', 'C'])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4</td>
      <td>7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>


인덱스로 행 삭제



```python
df.drop([0,1])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>


#### insert


i 위치에 색인이 추가된 새로운 색인 반환



```python
df = pd.DataFrame({'col1': [1,2], 'col2': [3,4]})
```


```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>col2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.insert(1, "newcol", [99,99])
```


```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>newcol</th>
      <th>col2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>99</td>
      <td>3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>99</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.insert(0, "col1", [100,100], allow_duplicates=True)
```


```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>col1</th>
      <th>newcol</th>
      <th>col2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>100</td>
      <td>1</td>
      <td>99</td>
      <td>3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>100</td>
      <td>2</td>
      <td>99</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>


Pandas는 Series 유형의 값인 경우 인덱스 정렬 사용



```python
df.insert(0, "col0", pd.Series([5,6], index=[1,2]))
```


```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col0</th>
      <th>col1</th>
      <th>col1</th>
      <th>newcol</th>
      <th>col2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>NaN</td>
      <td>100</td>
      <td>1</td>
      <td>99</td>
      <td>3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5.0</td>
      <td>100</td>
      <td>2</td>
      <td>99</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>


#### is_unique


중복되는 색인이 없다면 True반환



```python
idx = pd.Index([1,5,7,7])
```


```python
idx.is_unique
```

<pre>
False
</pre>

```python
idx = pd.Index([1,5,7])
```


```python
idx.is_unique
```

<pre>
True
</pre>

```python
idx = pd.Index(["Watermelon", "Orange", "Apple",
               "Watermelon"]).astype("category")
```


```python
idx.is_unique
```

<pre>
False
</pre>

```python
idx = pd.Index(["Orange", "Apple",
               "Watermelon"]).astype("category")
```


```python
idx.is_unique
```

<pre>
True
</pre>
#### unique


색인에서 중복되는 요소를 제거하고 유일한 값만 반환



```python
pd.Series([2,1,3,3], name = 'A').unique()
```

<pre>
array([2, 1, 3], dtype=int64)
</pre>
## 5.2 핵심 기능


### 5.2.1 재색인


#### reindex


pandas 객체의 중요한 기능 중 하나는 reindex인데, 새로운 색인에 ***맞도록*** 객체를 새로 생성



```python
obj = pd.Series([4.5, 7.2, -5.3, 3.6], index = ['d', 'b', 'a', 'c'])
```


```python
obj
```

<pre>
d    4.5
b    7.2
a   -5.3
c    3.6
dtype: float64
</pre>
이 Series 객체에 대해 reindex를 호출하면 데이터를 새로운 색인에 맞게 재배열하고, <br>

존재하지 않는 색인값이 있다면 NaN을 추가



```python
obj2 = obj.reindex(['a', 'b', 'c', 'd', 'e'])
```


```python
obj2
```

<pre>
a   -5.3
b    7.2
c    3.6
d    4.5
e    NaN
dtype: float64
</pre>
#### method


시계열 같은 순차적인 데이터를 재색인할 때 값을 보간하거나 채워 넣어야 할 경우가 있다<br>

method 옵션을 이용해 이를 해결 가능하며, ffill 같은 메서드를 이용해 누락된 값을 직전의 값으로 채워넣을 수 있다



```python
obj3 = pd.Series(['blue', 'purple', 'yellow'], index = [0,2,4])
```


```python
obj3
```

<pre>
0      blue
2    purple
4    yellow
dtype: object
</pre>

```python
obj3.reindex(range(6), method='ffill')
```

<pre>
0      blue
1      blue
2    purple
3    purple
4    yellow
5    yellow
dtype: object
</pre>
DataFrame에 대한 reindex는 로우(색인), 컬럼 또는 둘 다 변경 가능<br>

그냥 순서만 전달하면 로우가 재색인됨



```python
frame = pd.DataFrame(np.arange(9).reshape((3,3)), 
                     index=['a', 'c', 'd'], 
                     columns = ['Ohio', 'Texas', 'California'])
```


```python
frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ohio</th>
      <th>Texas</th>
      <th>California</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>c</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>d</th>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame2 = frame.reindex(['a', 'b', 'c', 'd'])
```


```python
frame2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ohio</th>
      <th>Texas</th>
      <th>California</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>6.0</td>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
  </tbody>
</table>
</div>



```python
#### columns
```

컬럼은 columns 예약어를 사용해 재색인 가능



```python
states = ['Texas', 'Utah', 'California']
```


```python
frame.reindex(columns=states)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Texas</th>
      <th>Utah</th>
      <th>California</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1</td>
      <td>NaN</td>
      <td>2</td>
    </tr>
    <tr>
      <th>c</th>
      <td>4</td>
      <td>NaN</td>
      <td>5</td>
    </tr>
    <tr>
      <th>d</th>
      <td>7</td>
      <td>NaN</td>
      <td>8</td>
    </tr>
  </tbody>
</table>
</div>


#### 재색인 함수 인자


|인자|설명|

|---|---|

|index|색인으로 사용할 새로운 순서. Index 인스턴스나 다른 순차적인 자료구조가 사용 가능. Index는 복사가 이루어지지 않고 그대로 사용됨|

|method|채움 메서드. ffill은 직전 값을 채워 넣고 bfill은 다음 값을 채워 넣음|

|fill_value|재색인 과정 중에 새롭게 나타나는 비어 있는 데이터를 채우기 위한 값|

|limit|전/후 보간 시에 사용할 최대 갭 크기(채워넣을 원소의 수)|

|tolerance|전/후 보간 시에 사용할 최대 갭 크기(값의 차이)|

|level|MultiIndex의 단계(level)에 단순 색인을 맞춤. 그렇지 않으면 MultiIndex의 하위집합에 맞춤|

|copy|True인 경우 새로운 색인이 이전 색인과 동일하더라도 데이터 복사. False인 경우 새로운 색인이 이전 색인과 동일할 경우 복사 X|


### 5.2.2 하나의 로우나 컬럼 삭제(drop)


색인 배열, 또는 삭제하려는 로우나 컬럼이 제외된 리스트를 이미 가지고 있다면 로우나 컬럼을 쉽게 삭제할 수 있는데<br>

이 방법은 데이터의 모양을 변경하는 작업이 필요<br>

drop 메서드를 사용하면 선택한 값들이 삭제된 새로운 객체를 얻을 수 있음



```python
obj = pd.Series(np.arange(5.), index=['a', 'b', 'c', 'd', 'e'])
```


```python
obj
```

<pre>
a    0.0
b    1.0
c    2.0
d    3.0
e    4.0
dtype: float64
</pre>

```python
new_obj = obj.drop('c')
```


```python
new_obj
```

<pre>
a    0.0
b    1.0
d    3.0
e    4.0
dtype: float64
</pre>

```python
obj.drop(['d', 'c'])
```

<pre>
a    0.0
b    1.0
e    4.0
dtype: float64
</pre>
DataFrame에서는 로우와 컬럼 모두에서 값을 삭제 가능



```python
data = pd.DataFrame(np.arange(16).reshape((4,4)),
                   index=['Ohio', 'Colorado', 'Utah', 'New York'],
                   columns = ['one', 'two', 'three', 'four'])
```


```python
data
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
  </tbody>
</table>
</div>


drop 함수에 인자로 로우 이름을 넘기면 해당 로우(axis 0)의 값을 모두 삭제



```python
data.drop(['Colorado', 'Ohio'])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
  </tbody>
</table>
</div>


#### axis = 1, axis='columns'


컬럼의 값을 삭제할 때는 axis = 1 또는 axis='columns'를 인자로 넘겨주면 된다



```python
data.drop('two', axis = 1)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>4</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>14</td>
      <td>15</td>
    </tr>
  </tbody>
</table>
</div>



```python
data.drop(['two', 'four'], axis='columns')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>three</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>2</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>4</td>
      <td>6</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>10</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>14</td>
    </tr>
  </tbody>
</table>
</div>


drop 함수처럼 Serires나 DataFrame의 크기 또는 형태를 변경하는 함수는 새로운 객체를 반환하는 대신 원본 객체를 변경함



```python
obj
```

<pre>
a    0.0
b    1.0
c    2.0
d    3.0
e    4.0
dtype: float64
</pre>

```python
obj.drop('c', inplace=True)
```


```python
obj
```

<pre>
a    0.0
b    1.0
d    3.0
e    4.0
dtype: float64
</pre>
inplace 옵션을 사용하는 경우 버려지는 값을 모두 삭제하므로 주의해서 사용하자


### 5.2.3 색인하기, 선택하기, 거르기


Series의 색인(obj[...])은 NumPy 배열의 색인과 유사하게 동작하지만 정수가 아니어도 된다는 점이 다름



```python
obj = pd.Series(np.arange(4.), index = ['a', 'b', 'c', 'd'])
```


```python
obj
```

<pre>
a    0.0
b    1.0
c    2.0
d    3.0
dtype: float64
</pre>

```python
obj['b']
```

<pre>
1.0
</pre>

```python
obj[1]
```

<pre>
1.0
</pre>

```python
obj[2:4]
```

<pre>
c    2.0
d    3.0
dtype: float64
</pre>

```python
obj[['b', 'a', 'd']]
```

<pre>
b    1.0
a    0.0
d    3.0
dtype: float64
</pre>

```python
obj[[1,3]]
```

<pre>
b    1.0
d    3.0
dtype: float64
</pre>

```python
obj[obj<2]
```

<pre>
a    0.0
b    1.0
dtype: float64
</pre>
라벨 이름으로 슬라이싱하면 시작점과 끝점을 포함한다는 것이 일반 파이썬의 슬라이싱과 다른 점



```python
obj
```

<pre>
a    0.0
b    1.0
c    2.0
d    3.0
dtype: float64
</pre>

```python
obj['b':'c']
```

<pre>
b    1.0
c    2.0
dtype: float64
</pre>
슬라이싱 문법으로 선택된 영역에 값을 대입하는 것은 생각하는 대로 동작



```python
obj['b':'c'] = 5
```


```python
obj
```

<pre>
a    0.0
b    5.0
c    5.0
d    3.0
dtype: float64
</pre>
색인으로 DataFrame에서 하나 이상의 컬럼 값을 가져올 수 있음



```python
data = pd.DataFrame(np.arange(16).reshape((4,4)),
                   index = ['Ohio', 'Colorado', 'Utah', 'New York'],
                   columns = ['one',  'two', 'three', 'four'])
```


```python
data
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
  </tbody>
</table>
</div>



```python
data['two']
```

<pre>
Ohio         1
Colorado     5
Utah         9
New York    13
Name: two, dtype: int32
</pre>

```python
data[['three', 'one']]
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>three</th>
      <th>one</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>6</td>
      <td>4</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>10</td>
      <td>8</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>14</td>
      <td>12</td>
    </tr>
  </tbody>
</table>
</div>


슬라이싱으로 로우를 선택하거나 불리언 배열로 로우 선택 가능



```python
data[:2]
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div>



```python
data[data['three']> 5]
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Colorado</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
  </tbody>
</table>
</div>


data[:2] 형식의 문법으로 편리하게 로우 선택 가능<br>

[] 연산자에 단일 값을 넘기거나 리스트를 넘겨서 여러 컬럼 선택 가능


또 다른 방법으로는 스칼라 비교를 이용해 생성된 불리언 DataFrame을 사용해 값을 선택하는 것



```python
data
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
  </tbody>
</table>
</div>



```python
data < 5
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>True</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>



```python
data[data<5] = 0
```


```python
data
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>0</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
  </tbody>
</table>
</div>


#### loc와 iloc로 선택하기


축 이름을 선택할 때는 loc을, 정수 색인으로 선택할 때는 iloc(integer loaction) 사용


축의 라벨로 하나의 로우와 여러 컬럼 선택하기



```python
data
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>0</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
  </tbody>
</table>
</div>



```python
data.loc['Colorado', ['two', 'three']]
```

<pre>
two      5
three    6
Name: Colorado, dtype: int32
</pre>
iloc를 이용하면 정수 색인으로도 위와 비슷하게 선택 가능



```python
data.iloc[2, [3,0,1]]
```

<pre>
four    11
one      8
two      9
Name: Utah, dtype: int32
</pre>

```python
data.iloc[[1,2],[3,0,1]]
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>four</th>
      <th>one</th>
      <th>two</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Colorado</th>
      <td>7</td>
      <td>0</td>
      <td>5</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>11</td>
      <td>8</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>


이 두 함수는 슬라이스도 지원할 뿐더러 단일 라벨이나 라벨 리스트도 지원



```python
data
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
      <th>four</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>0</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
  </tbody>
</table>
</div>



```python
data.loc[:'Utah',  'two']
```

<pre>
Ohio        0
Colorado    5
Utah        9
Name: two, dtype: int32
</pre>

```python
data.iloc[:, :3][data.three > 5]
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
      <th>three</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Colorado</th>
      <td>0</td>
      <td>5</td>
      <td>6</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
    </tr>
  </tbody>
</table>
</div>


### 5.2.4 정수 색인


정수 색인으로 pandas 객체를 다루다보면 리스트나 튜플 같은 파이썬 내장 자료구조에서 색인을 다루는 방법과의 차이점 때문에 실수하게 되는 경우가 있음<br>

예를 들어 다음 코드가 에러를 발생할 것이라고 생각하지 않을 것임



```python
ser = pd.Series(np.arange(3.))
```


```python
ser
```

<pre>
0    0.0
1    1.0
2    2.0
dtype: float64
</pre>

```python
ser[-1]
```

이 경우 pandas는 라벨 색인을 찾는 데 실패하므로 정수 색인으로 값을 찾음.<br>

하지만 이를 어떤 경우에도 버그 없이 잘 작동하도록 구현하기란 쉽지 않음<br>

라벨 색인이 0,1,2를 포함하는 경우 사용자가 라벨 색인으로 선택하려는 것인지 정수 색인으로 선택하려는 것인지 추측하기 쉽지 않음



```python
ser
```

<pre>
0    0.0
1    1.0
2    2.0
dtype: float64
</pre>
반면 정수 기반의 색인을 사용하지 않는 경우 이러한 모호함은 사라짐



```python
ser2 = pd.Series(np.arange(3.), index=['a', 'b', 'c'])
ser2
```

<pre>
a    0.0
b    1.0
c    2.0
dtype: float64
</pre>

```python
ser2[-1]
```

<pre>
2.0
</pre>
일관성을 유지하기 위해 정숫값을 담고 있는 축 색인이 있다면 우선적으로 라벨을 먼저 찾아보도록 구현되어 있음<br>

좀 더 세밀하게 사용하고 싶다면 라벨에 대해서는 loc를, 정수 색인에 대해서는 iloc를 사용



```python
ser[:1]
```

<pre>
0    0.0
dtype: float64
</pre>

```python
ser.loc[:1]
```

<pre>
0    0.0
1    1.0
dtype: float64
</pre>

```python
ser.iloc[:1]
```

<pre>
0    0.0
dtype: float64
</pre>
### 5.2.5. 산술 연산과 데이터 정렬


객체를 더할 때 짝이 맞지 않는 색인이 있다면 결과에 두 색인 통합



```python
s1 = pd.Series([7.3, -2.5, 3.4, 1.5], index = ['a', 'c', 'd', 'e'])
```


```python
s2 = pd.Series([-2.1, 3.6, -1.5, 4, 3.1],
              index=['a', 'c', 'e', 'f', 'g'])
```


```python
s1
```

<pre>
a    7.3
c   -2.5
d    3.4
e    1.5
dtype: float64
</pre>

```python
s2
```

<pre>
a   -2.1
c    3.6
e   -1.5
f    4.0
g    3.1
dtype: float64
</pre>
이 두 객체를 더하면 다음과 같은 결과를 얻음



```python
s1 + s2
```

<pre>
a    5.2
c    1.1
d    NaN
e    0.0
f    NaN
g    NaN
dtype: float64
</pre>
서로 겹치는 색인이 없는 경우 데이터는 NA값이 됨


DataFrame의 경우 정렬은 로우와 컬럼 모두에 적용



```python
df1 = pd.DataFrame(np.arange(9.).reshape((3,3)), columns=list('bcd'),
                  index=['Ohio', 'Texas', 'Colorado'])
```


```python
df2 = pd.DataFrame(np.arange(12.).reshape((4,3)), columns = list('bde'),
                  index=['Utah', 'Ohio', 'Texas', 'Oregon'])
```


```python
df1
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Ohio</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>Colorado</th>
      <td>6.0</td>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
  </tbody>
</table>
</div>



```python
df2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>6.0</td>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>9.0</td>
      <td>10.0</td>
      <td>11.0</td>
    </tr>
  </tbody>
</table>
</div>



```python
df1 + df2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Colorado</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>3.0</td>
      <td>NaN</td>
      <td>6.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>9.0</td>
      <td>NaN</td>
      <td>12.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Utah</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>


'c'와 'e' 컬럼이 양쪽 DataFrame 객체에 존재하지 않으므로 결과에서는 모두 없는 값<br>

로우 역시 마찬가지로 양쪽에 다 존재하지 않는 라벨에 대해서는 없는 값으로 나타남


공통되는 컬럼 라벨이나 로우 라벨이 없는 DataFrame을 더하면 결과에 아무것도 안 나타남



```python
df1 = pd.DataFrame({'A': [1,2]})
df2 = pd.DataFrame({'B': [3,4]})
```


```python
df1
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>



```python
df2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



```python
df1 - df2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>


#### 산술 연산 메서드에 채워 넣을 값 지정하기


서로 다른 색인을 가지는 객체 간의 산술 연산에서 존재하지 않는 축의 값을 특수한 값(0 같은)으로 지정하고 싶을 때는 다음과 같이 할 수 있음



```python
df1 = pd.DataFrame(np.arange(12.).reshape((3,4)),
                   columns = list('abcd'))
```


```python
df2 = pd.DataFrame(np.arange(20.).reshape((4,5)),
                  columns = list('abcde'))
```


```python
df2.loc[1, 'b'] = np.nan
```


```python
df1
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.0</td>
      <td>5.0</td>
      <td>6.0</td>
      <td>7.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8.0</td>
      <td>9.0</td>
      <td>10.0</td>
      <td>11.0</td>
    </tr>
  </tbody>
</table>
</div>



```python
df2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5.0</td>
      <td>NaN</td>
      <td>7.0</td>
      <td>8.0</td>
      <td>9.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10.0</td>
      <td>11.0</td>
      <td>12.0</td>
      <td>13.0</td>
      <td>14.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>15.0</td>
      <td>16.0</td>
      <td>17.0</td>
      <td>18.0</td>
      <td>19.0</td>
    </tr>
  </tbody>
</table>
</div>


위 둘을 더하면 겹치지 않는 부분은 NA 값이 됨



```python
df1 + df2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>2.0</td>
      <td>4.0</td>
      <td>6.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>9.0</td>
      <td>NaN</td>
      <td>13.0</td>
      <td>15.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>18.0</td>
      <td>20.0</td>
      <td>22.0</td>
      <td>24.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>


df1에 add 메서드를 사용하고, df2와 fill_value 값을 인자로 전달



```python
df1.add(df2, fill_value=0)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>2.0</td>
      <td>4.0</td>
      <td>6.0</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>9.0</td>
      <td>5.0</td>
      <td>13.0</td>
      <td>15.0</td>
      <td>9.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>18.0</td>
      <td>20.0</td>
      <td>22.0</td>
      <td>24.0</td>
      <td>14.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>15.0</td>
      <td>16.0</td>
      <td>17.0</td>
      <td>18.0</td>
      <td>19.0</td>
    </tr>
  </tbody>
</table>
</div>


- 산술 연산 메서드


|메서드|설명|

|---|---|

|add, radd| 덧셈(+)을 위한 메서드|

|sub, rsub| 뺄셈(-)을 위한 메서드|

|div, rdiv| 나눗셈(/)을 위한 메서드|

|floordiv, rfloordiv|소수점 내림(//) 연산을 위한 메서드|

|mul, rmul| 곱셈(*)을 위한 메서드|

|pow, rpow|멱승(**)을 위한 메서드|


각각의 산술 연산 메서드는 r로 시작하는, 계산 인자를 뒤집어 계산하는 짝궁 메서드를 가짐



```python
df1
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.0</td>
      <td>5.0</td>
      <td>6.0</td>
      <td>7.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8.0</td>
      <td>9.0</td>
      <td>10.0</td>
      <td>11.0</td>
    </tr>
  </tbody>
</table>
</div>



```python
1/df1
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>inf</td>
      <td>1.000000</td>
      <td>0.500000</td>
      <td>0.333333</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.250</td>
      <td>0.200000</td>
      <td>0.166667</td>
      <td>0.142857</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.125</td>
      <td>0.111111</td>
      <td>0.100000</td>
      <td>0.090909</td>
    </tr>
  </tbody>
</table>
</div>



```python
df1.rdiv(1)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>inf</td>
      <td>1.000000</td>
      <td>0.500000</td>
      <td>0.333333</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.250</td>
      <td>0.200000</td>
      <td>0.166667</td>
      <td>0.142857</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.125</td>
      <td>0.111111</td>
      <td>0.100000</td>
      <td>0.090909</td>
    </tr>
  </tbody>
</table>
</div>


Series나 DataFrame을 재색인할 때도 fill_value 지정 가능



```python
df1.reindex(columns = df2.columns, fill_value = 0)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.0</td>
      <td>5.0</td>
      <td>6.0</td>
      <td>7.0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8.0</td>
      <td>9.0</td>
      <td>10.0</td>
      <td>11.0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>


#### DataFrame과 Series 간의 연산


2차원 배열과 그 배열의 한 로우의 차이에 대해 생각할 수 있는 예제를 살펴보자



```python
arr = np.arange(12.).reshape((3,4))
```


```python
arr
```

<pre>
array([[ 0.,  1.,  2.,  3.],
       [ 4.,  5.,  6.,  7.],
       [ 8.,  9., 10., 11.]])
</pre>

```python
arr[0]
```

<pre>
array([0., 1., 2., 3.])
</pre>

```python
arr - arr[0]
```

<pre>
array([[0., 0., 0., 0.],
       [4., 4., 4., 4.],
       [8., 8., 8., 8.]])
</pre>
arr에서 arr[0]을 빼면 계산은 각 로우에 대해 한 번씩만 수행. 이를 ***브로드캐스팅***이라고 함


Dataframe과 Series 간의 연산은 이와 유사



```python
import pandas as pd
```


```python
import numpy as np
frame = pd.DataFrame(np.arange(12.).reshape((4,3)),
                    columns = list('bde'),
                    index = ['Utah', 'Ohio', 'Texas', 'Oregon'])
```


```python
series = frame.iloc[0]
```


```python
frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>6.0</td>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>9.0</td>
      <td>10.0</td>
      <td>11.0</td>
    </tr>
  </tbody>
</table>
</div>



```python
series
```

<pre>
b    0.0
d    1.0
e    2.0
Name: Utah, dtype: float64
</pre>
기본적으로 DataFrame과 Series 간의 산술 연산은 Series의 색인을 DataFrame의 컬럼에 맞추고 아래 로우로 전파



```python
frame - series
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>3.0</td>
      <td>3.0</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>6.0</td>
      <td>6.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>9.0</td>
      <td>9.0</td>
      <td>9.0</td>
    </tr>
  </tbody>
</table>
</div>


만약 색인값을 DataFrame의 컬럼이나 Series의 색인에서 찾을 수 없다면 그 객체는 형식을 맞추기 위해 재색인됨



```python
series2 = pd.Series(range(3), index=['b', 'e', 'f'])
```


```python
series2
```

<pre>
b    0
e    1
f    2
dtype: int64
</pre>

```python
frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>6.0</td>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>9.0</td>
      <td>10.0</td>
      <td>11.0</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame + series2
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>0.0</td>
      <td>NaN</td>
      <td>3.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>3.0</td>
      <td>NaN</td>
      <td>6.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>6.0</td>
      <td>NaN</td>
      <td>9.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>9.0</td>
      <td>NaN</td>
      <td>12.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>


각 로우에 대해 연산 수행하고 싶다면 산술 연산 메서드 사용


##### sub



```python
series3 = frame['d']
```


```python
frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>0.0</td>
      <td>1.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>6.0</td>
      <td>7.0</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>9.0</td>
      <td>10.0</td>
      <td>11.0</td>
    </tr>
  </tbody>
</table>
</div>



```python
series3
```

<pre>
Utah       1.0
Ohio       4.0
Texas      7.0
Oregon    10.0
Name: d, dtype: float64
</pre>

```python
frame.sub(series3, axis='index')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>-1.0</td>
      <td>0.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>-1.0</td>
      <td>0.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>-1.0</td>
      <td>0.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>-1.0</td>
      <td>0.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>


인자로 넘기는 axis 값은 ***연산을 적용할 축 번호***<br>

axis='index'나 axis=0은 DataFrame의 로우를 따라 연산을 수행하라는 의미


### 5.2.6 함수 적용과 매핑


pandas 객체에도 Numpy의 유니버설 함수(배열의 각 원소에 적용되는 메서드)를 적용 가능


#### abs



```python
frame = pd.DataFrame(np.random.randn(4,3), columns=list('bde'),
                    index=['Utah', 'Ohio', 'Texas', 'Oregon'])
```


```python
frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>1.010608</td>
      <td>-0.510632</td>
      <td>-0.376996</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>-0.543456</td>
      <td>1.372457</td>
      <td>-0.596795</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>1.240963</td>
      <td>0.310329</td>
      <td>-0.357162</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>-0.946491</td>
      <td>-0.522856</td>
      <td>-0.360199</td>
    </tr>
  </tbody>
</table>
</div>



```python
np.abs(frame)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>1.010608</td>
      <td>0.510632</td>
      <td>0.376996</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>0.543456</td>
      <td>1.372457</td>
      <td>0.596795</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>1.240963</td>
      <td>0.310329</td>
      <td>0.357162</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>0.946491</td>
      <td>0.522856</td>
      <td>0.360199</td>
    </tr>
  </tbody>
</table>
</div>


#### apply


자주 사용되는 또 다른 연산은 각 컬럼이나 로우의 1차원 배열에 함수를 적용하는 것<br>

DataFrame의 apply 메서드를 이용해 수행 가능



```python
f = lambda x:x.max() - x.min()
```


```python
frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>1.010608</td>
      <td>-0.510632</td>
      <td>-0.376996</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>-0.543456</td>
      <td>1.372457</td>
      <td>-0.596795</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>1.240963</td>
      <td>0.310329</td>
      <td>-0.357162</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>-0.946491</td>
      <td>-0.522856</td>
      <td>-0.360199</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame.apply(f)
```

<pre>
b    2.187454
d    1.895314
e    0.239633
dtype: float64
</pre>
여기서 함수 f는 Series의 최댓값과 최솟값의 차이를 계산하는 함수<br>

frame의 각 컬럼에 대해 한 번만 수행되며 결괏값은 계산을 적용한 컬럼을 색인으로 하는 Series를 반환


apply 함수에 axis='columns'인자를 넘기면 각 로우에 대해 한 번씩만 수행



```python
frame.apply(f, axis='columns')
```

<pre>
Utah      1.521239
Ohio      1.969252
Texas     1.598125
Oregon    0.586292
dtype: float64
</pre>
배열에 대한 일반적인 통계(sum이나 mean 같은)는 DataFrame의 메서드로 존재하므로 apply 메서드를 사용할 필요가 X


apply 메서드에 전달된 함수는 스칼라값을 반환할 필요 X<br>

여러 값을 가진 Series 반환해도 됨



```python
def f(x):
    return pd.Series([x.min(), x.max()], index = ['min', 'max'])
```


```python
frame.apply(f)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>min</th>
      <td>-0.822696</td>
      <td>-1.334216</td>
      <td>-0.66891</td>
    </tr>
    <tr>
      <th>max</th>
      <td>1.476587</td>
      <td>2.232451</td>
      <td>0.66453</td>
    </tr>
  </tbody>
</table>
</div>


#### applymap


배열의 각 원소에 적용되는 파이썬의 함수 사용 가능<br>

frame 객체에서 실숫값을 문자열 포맷으로 변환하고 싶다면 applymap을 이용해 다음과 같이 할 수 있다



```python
frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>1.010608</td>
      <td>-0.510632</td>
      <td>-0.376996</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>-0.543456</td>
      <td>1.372457</td>
      <td>-0.596795</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>1.240963</td>
      <td>0.310329</td>
      <td>-0.357162</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>-0.946491</td>
      <td>-0.522856</td>
      <td>-0.360199</td>
    </tr>
  </tbody>
</table>
</div>



```python
format = lambda x: '%.2f'%x
```


```python
frame.applymap(format)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>d</th>
      <th>e</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Utah</th>
      <td>1.01</td>
      <td>-0.51</td>
      <td>-0.38</td>
    </tr>
    <tr>
      <th>Ohio</th>
      <td>-0.54</td>
      <td>1.37</td>
      <td>-0.60</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>1.24</td>
      <td>0.31</td>
      <td>-0.36</td>
    </tr>
    <tr>
      <th>Oregon</th>
      <td>-0.95</td>
      <td>-0.52</td>
      <td>-0.36</td>
    </tr>
  </tbody>
</table>
</div>


이 메서드의 이름이 applymap인 이유는 Series는 각 원소에 적용할 함수를 지정하기 위한 map메서드를 가지고 있기 때문



```python
frame['e'].map(format)
```

<pre>
Utah      -0.38
Ohio      -0.60
Texas     -0.36
Oregon    -0.36
Name: e, dtype: object
</pre>
### 5.2.7 정렬과 순위


#### sort_index


로우와 컬럼의 색인을 알파벳순으로 정렬하려면 정렬된 새로운 객체를 반환하는 sort_index 메서드 사용



```python
obj = pd.Series(range(4), index = ['d', 'a', 'b', 'c'])
obj
```

<pre>
d    0
a    1
b    2
c    3
dtype: int64
</pre>

```python
obj.sort_index()
```

<pre>
a    1
b    2
c    3
d    0
dtype: int64
</pre>
DataFrame은 로우나 컬럼 중 하나의 축을 기준으로 정렬 가능



```python
frame = pd.DataFrame(np.arange(8).reshape((2,4)),
                    index = ['three', 'one'],
                    columns = ['d', 'a', 'b', 'c'])
frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>d</th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>three</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>one</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame.sort_index()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>d</th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>one</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>three</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame.sort_index(axis=1)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>three</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>0</td>
    </tr>
    <tr>
      <th>one</th>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>


#### ascending


데이터는 기본적으로 오름차순으로 정렬되고 내림차순으로 정렬도 가능



```python
frame.sort_index(axis=1, ascending=False)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>d</th>
      <th>c</th>
      <th>b</th>
      <th>a</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>three</th>
      <td>0</td>
      <td>3</td>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <th>one</th>
      <td>4</td>
      <td>7</td>
      <td>6</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>


#### sort_values


Series 객체를 값에 따라 정렬하고 싶다면 sort_values 메서드 사용



```python
obj = pd.Series([4,7,-3,2])
obj
```

<pre>
0    4
1    7
2   -3
3    2
dtype: int64
</pre>

```python
obj.sort_values()
```

<pre>
2   -3
3    2
0    4
1    7
dtype: int64
</pre>
정렬할 때 비어 있는 값은 기본적으로 Series 객체에서 가장 마지막에 위치



```python
obj = pd.Series([4, np.nan, 7, np.nan, -3, 2])
obj
```

<pre>
0    4.0
1    NaN
2    7.0
3    NaN
4   -3.0
5    2.0
dtype: float64
</pre>

```python
obj.sort_values()
```

<pre>
4   -3.0
5    2.0
0    4.0
2    7.0
1    NaN
3    NaN
dtype: float64
</pre>
#### by


DataFrame에서 하나 이상의 컬럼에 있는 값으로 정렬을 하는 경우 sort_values 함수의 by 옵션에 하나 이상의 컬럼 이름을 넘기면 됨



```python
frame = pd.DataFrame({'b':[4,7,-3,2], 'a':[0,1,0,1]})
```


```python
frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>a</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>4</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>7</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-3</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame.sort_values(by='b')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>a</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>-3</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <th>0</th>
      <td>4</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>7</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>


여러 개의 컬럼을 정렬하려면 컬럼 이름이 담긴 리스트 전달



```python
frame.sort_values(by=['a', 'b'])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>a</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>-3</td>
      <td>0</td>
    </tr>
    <tr>
      <th>0</th>
      <td>4</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>7</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>


#### rank


***순위***는 정렬과 거의 흡사한데, 1부터 배열의 유효한 데이터 개수까지 순서를 매김<br>

기본적으로 Series와 DataFrame의 rank 메서드는 동점인 항목에 대해서는 평균 순위를 매김



```python
obj = pd.Series([7,-5, 7, 4, 2, 0, 4])
obj
```

<pre>
0    7
1   -5
2    7
3    4
4    2
5    0
6    4
dtype: int64
</pre>

```python
obj.rank()
```

<pre>
0    6.5
1    1.0
2    6.5
3    4.5
4    3.0
5    2.0
6    4.5
dtype: float64
</pre>
데이터 상에서 나타나는 순서에 따라 순위 매기기도 가능



```python
obj.rank(method='first')
```

<pre>
0    6.0
1    1.0
2    7.0
3    4.0
4    3.0
5    2.0
6    5.0
dtype: float64
</pre>
여기서 0번째와 2번째 항목에 대해 평균 순위인 6.5를 적용하는 대신 먼저 출현한 순서대로 6과 7을 적용


내림차순으로 순위 매기기도 가능



```python
obj
```

<pre>
0    7
1   -5
2    7
3    4
4    2
5    0
6    4
dtype: int64
</pre>

```python
#동률인 경우 그룹 내에서 높은 순위 적용
obj.rank(ascending=False, method='max')
```

<pre>
0    2.0
1    7.0
2    2.0
3    4.0
4    5.0
5    6.0
6    4.0
dtype: float64
</pre>
DataFrame에서는 로우나 컬럼에 대해 순위 정할 수 있음



```python
frame = pd.DataFrame({'b':[4.3, 7, -3, 2], 'a':[0,1,0,1],
                     'c':[-2,5,8,-2.5]})
```


```python
frame
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>a</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>4.3</td>
      <td>0</td>
      <td>-2.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>7.0</td>
      <td>1</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-3.0</td>
      <td>0</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2.0</td>
      <td>1</td>
      <td>-2.5</td>
    </tr>
  </tbody>
</table>
</div>



```python
frame.rank(axis='columns')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>b</th>
      <th>a</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>3.0</td>
      <td>2.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3.0</td>
      <td>1.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1.0</td>
      <td>2.0</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3.0</td>
      <td>2.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>


#### 순위의 동률을 처리하는 메서드


|메서드|설명|

|---|---|

|'average'|기본값. 같은 값을 가지는 항목들의 평균값을 순위로 삼음|

|'min'|같은 값을 가지는 그룹을 낮은 순위로 매김|

|'max'| 같은 값을 가지는 그룹을 높은 순위로 매김|

|'first'| 데이터 내의 위치에 따라 순위를 매김|

|'dense'|method='min'과 같지만 같은 그룹 내에서 모두 같은 순위를 적용하지 않고 1씩 증가시킴|


### 5.2.8 중복 색인


pandas의 많은 함수(reindex 같은)에서 색인값은 유일해야 하지만 의무적이지는 X<br>

중복된 색인값을 가지는 Series 객체를 살펴보자



```python
obj = pd.Series(range(5), index = ['a', 'a', 'b', 'b', 'c'])
```


```python
obj
```

<pre>
a    0
a    1
b    2
b    3
c    4
dtype: int64
</pre>
#### is_unique


is_unique 속성은 해당 값이 유일한지 아닌지 알려줌



```python
obj.index.is_unique
```

<pre>
False
</pre>
중복되는 색인값이 없을 때는 색인을 이용해 데이터에 접근하면 스칼라값을 반환하지만 <br>

중복되는 색인값이 있을 때는 하나의 Series 객체 반환



```python
obj['a']
```

<pre>
a    0
a    1
dtype: int64
</pre>

```python
obj['c']
```

<pre>
4
</pre>
DataFrame에서 로우를 선택하는 것도 동일



```python
df = pd.DataFrame(np.random.randn(4,3), index = ['a', 'a','b', 'b'])
```


```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>2.073031</td>
      <td>1.811255</td>
      <td>-0.516722</td>
    </tr>
    <tr>
      <th>a</th>
      <td>-0.736816</td>
      <td>-1.217630</td>
      <td>-0.182017</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1.314454</td>
      <td>0.055815</td>
      <td>0.898633</td>
    </tr>
    <tr>
      <th>b</th>
      <td>0.754281</td>
      <td>-0.823894</td>
      <td>0.269821</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.loc['b']
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>b</th>
      <td>1.314454</td>
      <td>0.055815</td>
      <td>0.898633</td>
    </tr>
    <tr>
      <th>b</th>
      <td>0.754281</td>
      <td>-0.823894</td>
      <td>0.269821</td>
    </tr>
  </tbody>
</table>
</div>


## 5.3 기술 통계 계산과 요약


pandas 객체는 일반적인 수학 메서드와 통계 메서드를 가짐<br>

이 메서드의 대부분은 하나의 Series나 DataFrame의 로우나 컬럼에서 단일 값(합이나 평균 같은)을 구하는 ***축소(reductions)*** <br>

혹은 ***요약 통계(summary statistics)*** 범주에 속함<br>

순수 NumPy 배열에서 제공하는 동일한 메서드와 비교해 pandas의 메서드는 처음부터 누락된 데이터를 제외하도록 설계됨



```python
df = pd.DataFrame([[1.4,np.nan], [7.1, -4.5],
                  [np.nan, np.nan], [0.75, -1.3]],
                 index = ['a', 'b', 'c', 'd'],
                 columns = ['one', 'two'])
```


```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.40</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>7.10</td>
      <td>-4.5</td>
    </tr>
    <tr>
      <th>c</th>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>d</th>
      <td>0.75</td>
      <td>-1.3</td>
    </tr>
  </tbody>
</table>
</div>


DataFrame의 sum 메서드를 호출하면 각 로우의 합을 담은 Series 반환



```python
df.sum()
```

<pre>
one    9.25
two   -5.80
dtype: float64
</pre>
axis='columns' 또는 axis=1 옵션을 넘기면 각 컬럼의 합을 반환



```python
df.sum(axis='columns')
```

<pre>
a    1.40
b    2.60
c    0.00
d   -0.55
dtype: float64
</pre>
전체 로우나 컬럼의 값이 NA가 아니라면 NA 값은 제외되고 계산<br>

이는 skipna 옵션으로 조정



```python
df.mean(axis='columns', skipna= False)
```

<pre>
a      NaN
b    1.300
c      NaN
d   -0.275
dtype: float64
</pre>
- 축소 메서드의 옵션


|옵션|설명|

|---|---|

|axis| 연산을 수행할 축. DataFrame에서 0은 로우고 1은 컬럼|

|skipna|누락된 값을 제외할 것인지 정하는 옵션. 기본값은 True|

|level|계산하려는 축이 계층적 색인(다중 색인)이라면 레벨에 따라 묶어서 계산|


### idxmax, idxmin


각각 축에서 최대/최소값의 인덱스 반환하는 메서드



```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.40</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>7.10</td>
      <td>-4.5</td>
    </tr>
    <tr>
      <th>c</th>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>d</th>
      <td>0.75</td>
      <td>-1.3</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.idxmax()
```

<pre>
one    b
two    d
dtype: object
</pre>

```python
df.idxmin()
```

<pre>
one    d
two    b
dtype: object
</pre>
### cumsum


누적합(accumulation) 계산



```python
df.cumsum()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.40</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>8.50</td>
      <td>-4.5</td>
    </tr>
    <tr>
      <th>c</th>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>d</th>
      <td>9.25</td>
      <td>-5.8</td>
    </tr>
  </tbody>
</table>
</div>


### describe


Series나 DataFrame의 각 컬럼에 대한 요약 통계 계산



```python
df.describe()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>one</th>
      <th>two</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>3.000000</td>
      <td>2.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>3.083333</td>
      <td>-2.900000</td>
    </tr>
    <tr>
      <th>std</th>
      <td>3.493685</td>
      <td>2.262742</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.750000</td>
      <td>-4.500000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>1.075000</td>
      <td>-3.700000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>1.400000</td>
      <td>-2.900000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>4.250000</td>
      <td>-2.100000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>7.100000</td>
      <td>-1.300000</td>
    </tr>
  </tbody>
</table>
</div>


수치 데이터가 아닐 경우 describe는 다른 요약 통계 생성



```python
obj = pd.Series(['a', 'a', 'b', 'c']*4)
```


```python
obj
```

<pre>
0     a
1     a
2     b
3     c
4     a
5     a
6     b
7     c
8     a
9     a
10    b
11    c
12    a
13    a
14    b
15    c
dtype: object
</pre>

```python
obj.describe()
```

<pre>
count     16
unique     3
top        a
freq       8
dtype: object
</pre>
### count



```python
df = pd.DataFrame({"Person":
                   ["John", "Myla", "Lewis", "John", "Myla"],
                   "Age": [24., np.nan, 21., 33, 26],
                   "Single": [False, True, True, True, False]})
```


```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Person</th>
      <th>Age</th>
      <th>Single</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>John</td>
      <td>24.0</td>
      <td>False</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Myla</td>
      <td>NaN</td>
      <td>True</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Lewis</td>
      <td>21.0</td>
      <td>True</td>
    </tr>
    <tr>
      <th>3</th>
      <td>John</td>
      <td>33.0</td>
      <td>True</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Myla</td>
      <td>26.0</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.count()
```

<pre>
Person    5
Age       4
Single    5
dtype: int64
</pre>

```python
df.count(axis='columns')
```

<pre>
0    3
1    2
2    3
3    3
4    3
dtype: int64
</pre>
### min, max 


최솟값과 최댓값 계산



```python
df = pd.DataFrame({'X': [1, 2, 2, 3],
                   'Y': [4, 3, 8, 4]})
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>X</th>
      <th>Y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>8</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.min()
```

<pre>
X    1
Y    3
dtype: int64
</pre>

```python
df.max()
```

<pre>
X    3
Y    8
dtype: int64
</pre>
### argmin, argmax


각각 최솟값과 최댓값을 담고 있는 색인의 위치(정수) 반환



```python
s = pd.Series({'Corn Flakes': 100.0, 'Almond Delight': 110.0,
               'Cinnamon Toast Crunch': 120.0, 'Cocoa Puff': 110.0})
s
```

<pre>
Corn Flakes              100.0
Almond Delight           110.0
Cinnamon Toast Crunch    120.0
Cocoa Puff               110.0
dtype: float64
</pre>

```python
s.argmin()
```

<pre>
0
</pre>

```python
s.argmax()
```

<pre>
2
</pre>
### quantile


q의 값에 따라 해당 분위수 출력



```python
idx = ['row1','row2','row3']
col = ['col1','col2','col3']
data= [[0,1,32],[50,10,-9],[100,100,18]]

df = pd.DataFrame(data,idx,col)
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>col2</th>
      <th>col3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>row1</th>
      <td>0</td>
      <td>1</td>
      <td>32</td>
    </tr>
    <tr>
      <th>row2</th>
      <td>50</td>
      <td>10</td>
      <td>-9</td>
    </tr>
    <tr>
      <th>row3</th>
      <td>100</td>
      <td>100</td>
      <td>18</td>
    </tr>
  </tbody>
</table>
</div>



```python
#0분위수인 가장 작은 수 출력
df.quantile(q=0)
```

<pre>
col1    0.0
col2    1.0
col3   -9.0
Name: 0.0, dtype: float64
</pre>

```python
#0.5분위수인 중간값 출력
df.quantile(q=0.5)
```

<pre>
col1    50.0
col2    10.0
col3    18.0
Name: 0.5, dtype: float64
</pre>

```python
#1분위수인 가장 큰 값 출력
df.quantile(q=1)
```

<pre>
col1    100.0
col2    100.0
col3     32.0
Name: 1.0, dtype: float64
</pre>
### sum


합을 계산



```python
col = ['col1','col2','col3']
row = ['row1','row2','row3']
data = [[1,2,3],[4,5,6],[7,np.NaN,9]]
df = pd.DataFrame(data=data,index=row,columns=col)
```


```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>col2</th>
      <th>col3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>row1</th>
      <td>1</td>
      <td>2.0</td>
      <td>3</td>
    </tr>
    <tr>
      <th>row2</th>
      <td>4</td>
      <td>5.0</td>
      <td>6</td>
    </tr>
    <tr>
      <th>row3</th>
      <td>7</td>
      <td>NaN</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.sum(axis = 0)
```

<pre>
col1    12.0
col2     7.0
col3    18.0
dtype: float64
</pre>

```python
df.sum(axis=1)
```

<pre>
row1     6.0
row2    15.0
row3    16.0
dtype: float64
</pre>
### mean


평균 계산



```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>col2</th>
      <th>col3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>row1</th>
      <td>1</td>
      <td>2.0</td>
      <td>3</td>
    </tr>
    <tr>
      <th>row2</th>
      <td>4</td>
      <td>5.0</td>
      <td>6</td>
    </tr>
    <tr>
      <th>row3</th>
      <td>7</td>
      <td>NaN</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.mean(axis=0)
```

<pre>
col1    4.0
col2    3.5
col3    6.0
dtype: float64
</pre>

```python
df.mean(axis=1)
```

<pre>
row1    2.0
row2    5.0
row3    8.0
dtype: float64
</pre>
### median

중간값(50%분위) 반환<br>

만약 수의 갯수가 짝수이면 중앙값 두 값의 평균값 반환



```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>col2</th>
      <th>col3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>row1</th>
      <td>1</td>
      <td>2.0</td>
      <td>3</td>
    </tr>
    <tr>
      <th>row2</th>
      <td>4</td>
      <td>5.0</td>
      <td>6</td>
    </tr>
    <tr>
      <th>row3</th>
      <td>7</td>
      <td>NaN</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.median()
```

<pre>
col1    4.0
col2    3.5
col3    6.0
dtype: float64
</pre>

```python
df.median(axis=1)
```

<pre>
row1    2.0
row2    5.0
row3    8.0
dtype: float64
</pre>
### mad

평균값에서 평균절대편차 계산



```python
df.mad()
```

<pre>
C:\Users\user\AppData\Local\Temp\ipykernel_7108\3844944795.py:1: FutureWarning: The 'mad' method is deprecated and will be removed in a future version. To compute the same result, you may do `(df - df.mean()).abs().mean()`.
  df.mad()
</pre>
<pre>
col1    2.0
col2    1.5
col3    2.0
dtype: float64
</pre>
### prod

모든 값의 곱



```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>col2</th>
      <th>col3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>row1</th>
      <td>1</td>
      <td>2.0</td>
      <td>3</td>
    </tr>
    <tr>
      <th>row2</th>
      <td>4</td>
      <td>5.0</td>
      <td>6</td>
    </tr>
    <tr>
      <th>row3</th>
      <td>7</td>
      <td>NaN</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.prod()
```

<pre>
col1     28.0
col2     10.0
col3    162.0
dtype: float64
</pre>

```python
df.prod(axis=1)
```

<pre>
row1      6.0
row2    120.0
row3     63.0
dtype: float64
</pre>
### var

표본분산의 값 계산



```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>col2</th>
      <th>col3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>row1</th>
      <td>1</td>
      <td>2.0</td>
      <td>3</td>
    </tr>
    <tr>
      <th>row2</th>
      <td>4</td>
      <td>5.0</td>
      <td>6</td>
    </tr>
    <tr>
      <th>row3</th>
      <td>7</td>
      <td>NaN</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>



```python
df.var()
```

<pre>
col1    9.0
col2    4.5
col3    9.0
dtype: float64
</pre>

```python
df.var(axis=1)
```

<pre>
row1    1.0
row2    1.0
row3    2.0
dtype: float64
</pre>
### std

표본표준편차의 값 계산



```python
df.std()
```

<pre>
col1    3.00000
col2    2.12132
col3    3.00000
dtype: float64
</pre>

```python
df.std(axis=1)
```

<pre>
row1    1.000000
row2    1.000000
row3    1.414214
dtype: float64
</pre>
### skew

표본비대칭도(3차 적률) 값 계산


### kurt

표본첨도(4차 적률)의 값 계산


### cumprod

누적곱 계산


### diff

1차 산술차 계산(시계열 데이터 처리 시 유용)


### pct_change

퍼센트 변화율 계산


### 5.3.1 상관관계와 공분산


상관관계나 공분산 같은 요약 통계 계산은 두 쌍의 인자를 필요로 함<br>

pandas-datareader 패키지를 이용해서 야후! 금융 사이트에서 구한 주식가격과 시가총액을 담고 있는 다음 DataFrame을 생각해보자<bR>

아직 설치하지 않았다면 conda나 pip을 통해 설치 가능



```python
!pip install yahoo_fin
```

<pre>
Requirement already satisfied: yahoo_fin in c:\users\user\anaconda3\lib\site-packages (0.8.9.1)
Requirement already satisfied: feedparser in c:\users\user\anaconda3\lib\site-packages (from yahoo_fin) (6.0.10)
Requirement already satisfied: requests in c:\users\user\anaconda3\lib\site-packages (from yahoo_fin) (2.28.1)
Requirement already satisfied: pandas in c:\users\user\anaconda3\lib\site-packages (from yahoo_fin) (1.5.3)
Requirement already satisfied: requests-html in c:\users\user\anaconda3\lib\site-packages (from yahoo_fin) (0.10.0)
Requirement already satisfied: sgmllib3k in c:\users\user\anaconda3\lib\site-packages (from feedparser->yahoo_fin) (1.0.0)
Requirement already satisfied: python-dateutil>=2.8.1 in c:\users\user\anaconda3\lib\site-packages (from pandas->yahoo_fin) (2.8.2)
Requirement already satisfied: numpy>=1.21.0 in c:\users\user\anaconda3\lib\site-packages (from pandas->yahoo_fin) (1.23.5)
Requirement already satisfied: pytz>=2020.1 in c:\users\user\anaconda3\lib\site-packages (from pandas->yahoo_fin) (2022.7)
Requirement already satisfied: urllib3<1.27,>=1.21.1 in c:\users\user\anaconda3\lib\site-packages (from requests->yahoo_fin) (1.26.14)
Requirement already satisfied: certifi>=2017.4.17 in c:\users\user\anaconda3\lib\site-packages (from requests->yahoo_fin) (2022.12.7)
Requirement already satisfied: charset-normalizer<3,>=2 in c:\users\user\anaconda3\lib\site-packages (from requests->yahoo_fin) (2.0.4)
Requirement already satisfied: idna<4,>=2.5 in c:\users\user\anaconda3\lib\site-packages (from requests->yahoo_fin) (3.4)
Requirement already satisfied: bs4 in c:\users\user\anaconda3\lib\site-packages (from requests-html->yahoo_fin) (0.0.1)
Requirement already satisfied: fake-useragent in c:\users\user\anaconda3\lib\site-packages (from requests-html->yahoo_fin) (1.1.3)
Requirement already satisfied: pyppeteer>=0.0.14 in c:\users\user\anaconda3\lib\site-packages (from requests-html->yahoo_fin) (1.0.2)
Requirement already satisfied: pyquery in c:\users\user\anaconda3\lib\site-packages (from requests-html->yahoo_fin) (2.0.0)
Requirement already satisfied: parse in c:\users\user\anaconda3\lib\site-packages (from requests-html->yahoo_fin) (1.19.0)
Requirement already satisfied: w3lib in c:\users\user\anaconda3\lib\site-packages (from requests-html->yahoo_fin) (1.21.0)
Requirement already satisfied: appdirs<2.0.0,>=1.4.3 in c:\users\user\anaconda3\lib\site-packages (from pyppeteer>=0.0.14->requests-html->yahoo_fin) (1.4.4)
Requirement already satisfied: tqdm<5.0.0,>=4.42.1 in c:\users\user\anaconda3\lib\site-packages (from pyppeteer>=0.0.14->requests-html->yahoo_fin) (4.64.1)
Requirement already satisfied: importlib-metadata>=1.4 in c:\users\user\anaconda3\lib\site-packages (from pyppeteer>=0.0.14->requests-html->yahoo_fin) (4.11.3)
Requirement already satisfied: websockets<11.0,>=10.0 in c:\users\user\anaconda3\lib\site-packages (from pyppeteer>=0.0.14->requests-html->yahoo_fin) (10.4)
Requirement already satisfied: pyee<9.0.0,>=8.1.0 in c:\users\user\anaconda3\lib\site-packages (from pyppeteer>=0.0.14->requests-html->yahoo_fin) (8.2.2)
Requirement already satisfied: six>=1.5 in c:\users\user\anaconda3\lib\site-packages (from python-dateutil>=2.8.1->pandas->yahoo_fin) (1.16.0)
Requirement already satisfied: beautifulsoup4 in c:\users\user\anaconda3\lib\site-packages (from bs4->requests-html->yahoo_fin) (4.12.2)
Requirement already satisfied: lxml>=2.1 in c:\users\user\anaconda3\lib\site-packages (from pyquery->requests-html->yahoo_fin) (4.9.1)
Requirement already satisfied: cssselect>=1.2.0 in c:\users\user\anaconda3\lib\site-packages (from pyquery->requests-html->yahoo_fin) (1.2.0)
Requirement already satisfied: zipp>=0.5 in c:\users\user\anaconda3\lib\site-packages (from importlib-metadata>=1.4->pyppeteer>=0.0.14->requests-html->yahoo_fin) (3.11.0)
Requirement already satisfied: colorama in c:\users\user\anaconda3\lib\site-packages (from tqdm<5.0.0,>=4.42.1->pyppeteer>=0.0.14->requests-html->yahoo_fin) (0.4.6)
Requirement already satisfied: soupsieve>1.2 in c:\users\user\anaconda3\lib\site-packages (from beautifulsoup4->bs4->requests-html->yahoo_fin) (2.4)
</pre>
pandas_datareader 모듈을 이용해 주가 정보를 다운로드



```python
import pandas as pd
import yahoo_fin.stock_info as si
all_data = {ticker: si.get_data(ticker)
            for ticker in ['AAPL', 'IBM', 'MSFT', 'GOOG']}
price = pd.DataFrame({ticker: data['adjclose']
                      for ticker, data in all_data.items()})
volume = pd.DataFrame({ticker: data['volume']
                       for ticker, data in all_data.items()}) 
```

각 주식의 퍼센트 변화율 계산



```python
returns = price.pct_change()
```


```python
returns.tail()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL</th>
      <th>IBM</th>
      <th>MSFT</th>
      <th>GOOG</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2023-03-29</th>
      <td>0.019791</td>
      <td>0.002861</td>
      <td>0.019184</td>
      <td>0.005328</td>
    </tr>
    <tr>
      <th>2023-03-30</th>
      <td>0.009890</td>
      <td>-0.003778</td>
      <td>0.012620</td>
      <td>-0.005692</td>
    </tr>
    <tr>
      <th>2023-03-31</th>
      <td>0.015644</td>
      <td>0.014471</td>
      <td>0.014962</td>
      <td>0.026451</td>
    </tr>
    <tr>
      <th>2023-04-03</th>
      <td>0.007702</td>
      <td>0.007400</td>
      <td>-0.003711</td>
      <td>0.008750</td>
    </tr>
    <tr>
      <th>2023-04-04</th>
      <td>-0.003250</td>
      <td>-0.003483</td>
      <td>-0.000174</td>
      <td>0.002002</td>
    </tr>
  </tbody>
</table>
</div>


corr 메서드는 NA가 아니며 정렬된 색인에서 연속하는 두 Series에 대해 상관관계를 계산하고<br>

cov 메서드는 공분산을 계산



```python
returns['MSFT'].corr(returns['IBM'])
```

<pre>
0.4445904937007664
</pre>

```python
returns['MSFT'].cov(returns['IBM'])
```

<pre>
0.00016305954795051904
</pre>
MSFT는 파이썬 속성 이름 규칙에 어긋나지 않으므로 좀 더 편리한 문법으로 해당 컬럼 선택 가능



```python
returns.MSFT.corr(returns.IBM)
```

<pre>
0.4445904937007664
</pre>
반면 DataFrame에서 corr과 cov 메서드는 DataFrame 행렬에서 상관관계와 공분산 계산



```python
returns.corr()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL</th>
      <th>IBM</th>
      <th>MSFT</th>
      <th>GOOG</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>AAPL</th>
      <td>1.000000</td>
      <td>0.370149</td>
      <td>0.430067</td>
      <td>0.521034</td>
    </tr>
    <tr>
      <th>IBM</th>
      <td>0.370149</td>
      <td>1.000000</td>
      <td>0.444590</td>
      <td>0.403267</td>
    </tr>
    <tr>
      <th>MSFT</th>
      <td>0.430067</td>
      <td>0.444590</td>
      <td>1.000000</td>
      <td>0.567250</td>
    </tr>
    <tr>
      <th>GOOG</th>
      <td>0.521034</td>
      <td>0.403267</td>
      <td>0.567250</td>
      <td>1.000000</td>
    </tr>
  </tbody>
</table>
</div>



```python
returns.cov()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL</th>
      <th>IBM</th>
      <th>MSFT</th>
      <th>GOOG</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>AAPL</th>
      <td>0.000796</td>
      <td>0.000175</td>
      <td>0.000252</td>
      <td>0.000212</td>
    </tr>
    <tr>
      <th>IBM</th>
      <td>0.000175</td>
      <td>0.000266</td>
      <td>0.000163</td>
      <td>0.000113</td>
    </tr>
    <tr>
      <th>MSFT</th>
      <td>0.000252</td>
      <td>0.000163</td>
      <td>0.000454</td>
      <td>0.000190</td>
    </tr>
    <tr>
      <th>GOOG</th>
      <td>0.000212</td>
      <td>0.000113</td>
      <td>0.000190</td>
      <td>0.000378</td>
    </tr>
  </tbody>
</table>
</div>


DataFrame의 corrwith 메서드를 사용하면 다른 Series나 DataFrame과의 상관관계 계산<br>

Series를 넘기면 각 컬럼에 대해 계산한 상관관계를 담고 있는 Series 반환



```python
returns.corrwith(returns.IBM)
```

<pre>
AAPL    0.370149
IBM     1.000000
MSFT    0.444590
GOOG    0.403267
dtype: float64
</pre>
DataFrame을 넘기면 맞아떨어지는 컬럼 이름에 대한 상관관계 계산<br>

시가총액의 퍼센트 변화율에 대한 상관관계를 계산해보자



```python
returns.corrwith(volume)
```

<pre>
AAPL    0.000411
IBM    -0.012531
MSFT   -0.005661
GOOG    0.038820
dtype: float64
</pre>
axis="columns" 옵션을 넘기면 각 컬럼에 대한 상관관계와 공분산 계산<br>

모든 경우 데이터는 상관관계를 계산하기 전에 색인의 이름순으로 정렬됨


### 5.3.2 유일값, 값 세기, 멤버십


1차원 Series에 담긴 값의 정보를 추출하는 메서드



```python
obj = pd.Series(['c', 'a', 'd', 'a', 'a', 'b', 'b', 'c', 'c'])
```

unique 메서드는 중복되는 값을 제거하고 유일값만 담고 있는 Series를 반환



```python
uniques = obj.unique()
```


```python
uniques
```

<pre>
array(['c', 'a', 'd', 'b'], dtype=object)
</pre>
유일값은 정렬된 순서대로 반환되지 않지만 필요하다면 uniques.sort()를 이용해 나중에 정렬 가능<br>

value_counts 메서드는 Series에서 도수(frequency)를 계산해 반환



```python
obj.value_counts()
```

<pre>
c    3
a    3
b    2
d    1
dtype: int64
</pre>
value_counts에서 반환하는 Series는 담고 있는 값을 내림차순으로 정렬<br>

value_counts 메서드는 pandas의 최상위 메서드로, 어떤 배열이나 순차 자료구조에서도 사용 가능



```python
pd.value_counts(obj.values, sort=False)
```

<pre>
c    3
a    3
d    1
b    2
dtype: int64
</pre>
isin 메서드는 어떤 값이 Series에 존재하는지 나타내는 불리언 벡터를 반환<br>

Series나 DataFrame의 컬럼에서 값을 골라내고 싶을 때 유용하게 사용 가능



```python
obj
```

<pre>
0    c
1    a
2    d
3    a
4    a
5    b
6    b
7    c
8    c
dtype: object
</pre>

```python
mask = obj.isin(['b', 'c'])
```


```python
mask
```

<pre>
0     True
1    False
2    False
3    False
4    False
5     True
6     True
7     True
8     True
dtype: bool
</pre>

```python
obj[mask]
```

<pre>
0    c
5    b
6    b
7    c
8    c
dtype: object
</pre>
isin과 관련이 있는 Index.get_indexer 메서드는 여러 값이 들어 있는 배열에서 유일한 값의 색인 배열 구할 수 있음



```python
to_match = pd.Series(['c', 'a', 'b', 'b', 'c', 'a'])
```


```python
unique_vals = pd.Series(['c', 'b', 'a'])
```


```python
pd.Index(unique_vals).get_indexer(to_match)
```

<pre>
array([0, 2, 1, 1, 0, 2], dtype=int64)
</pre>
#### 유일값, 갑 세기, 멤버십 메서드 정리


|메서드|설명|

|---|---|

|isin|Series의 각 원소가 넘겨받은 연속된 값에 속하는지 나타내는 불리언 배열 반환|

|match|각 값에 대해 유일한 값을 담고 있는 배열에서의 정수 색인을 계산. 데이터 정렬이나 조인 형태의 연산을 하는 경우에 유용|

|unique|Series에서 중복되는 값을 제거하고 유일값만 포함하는 배열 반환. 결과는 Series에서 발견된 순서대로 반환|

|value_counts|Series에서 유일값에 대한 색인과 도수 계산. 도수는 내림차순으로 정렬|


DataFrame의 여러 컬럼에 대해 히스토그램을 구해야 하는 경우가 있다. 다음 예제를 보자



```python
data = pd.DataFrame({'Qu1': [1,3,4,3,4],
                    'Qu2': [2,3,1,2,3],
                    'Qu3': [1,5,2,4,4]})
```


```python
data
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Qu1</th>
      <th>Qu2</th>
      <th>Qu3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3</td>
      <td>3</td>
      <td>5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>2</td>
      <td>4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>3</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>


위 DataFrame의 apply 함수에 pandas.value_counts를 넘기면 다음과 같은 결과를 얻을 수 있음



```python
result = data.apply(pd.value_counts).fillna(0)
```


```python
result
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Qu1</th>
      <th>Qu2</th>
      <th>Qu3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.0</td>
      <td>2.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2.0</td>
      <td>2.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2.0</td>
      <td>0.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>


여기서 결괏값의 로우 라벨은 전체 컬럼의 유일한 값들을 담고 있다<br>

각 값은 각 컬럼에서 해당값이 몇 번 출현했는지 나타냄


# 6장 데이터 로딩과 저장, 파일 형식


입출력의 종류

- 텍스트 파일을 이용하는 방법

- 데이터베이스를 이용하는 방법

- 웹 API를 이용해 네트워크를 통해 불러오는 방법


## 6.1 텍스트 파일에서 데이터를 읽고 쓰는 법


p.237참조<br>

pandas 파일 파싱 함수

- read_csv

- read_table

- read_fwf

- read_clipboard

- read_excel

- read_hdf

- read_html

- read_json

- read_msgpack

- read_pickle

- read_sas

- read_sql

- read_stata

- read_feather


위 함수들은 텍스트 데이터를 DataFrame으로 읽어오기 위한 함수인데, 아래와 같은 몇가지 옵션을 취함


***색인***

- 반환하는 DataFrame에서 하나 이상의 컬럼을 색인으로 지정 가능<br>

파일이나 사용자로부터 컬럼 이름을 받거나 아무것도 받지 않을 수 있음


***자료형 추론과 데이터 변환***

- 사용자 정의 값 변환과 비어 있는 값을 위한 사용자 리스트 포함


***날짜 분석***

- 여러 컬럼에 걸쳐 있는 날짜와 시간 정보를 하나의 컬럼에 조합해 결과에 반영


***반복***

- 여러 개의 파일에 걸쳐 있는 자료를 반복적으로 읽어올 수 있음


 ***정제되지 않은 데이터 처리***

- 로우나 꼬리말, 주석 건너뛰기 또는 천 단위마다 쉼표로 구분된 숫자 같은 사소한 것들의 처리를 해줌


pandas.read_csv 같은 함수들은 데이터 형식에 자료형이 포함되어 있지 않은 관계로 ***타입 추론*** 수행



```python
df = pd.read_csv('ex1.csv')
```


```python
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>message</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>hello</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>world</td>
    </tr>
    <tr>
      <th>2</th>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>foo</td>
    </tr>
  </tbody>
</table>
</div>


read_table에 구분자를 쉼표로 지정해서 읽어올 수도 있음



```python
pd.read_table('ex1.csv', sep=',')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>message</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>hello</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>world</td>
    </tr>
    <tr>
      <th>2</th>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>foo</td>
    </tr>
  </tbody>
</table>
</div>


pandas가 자동으로 컬럼 이름을 생성하도록 하거나 우리가 직접 컬럼 이름 지정하기



```python
pd.read_csv('ex2.csv', header=None)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>hello</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>world</td>
    </tr>
    <tr>
      <th>2</th>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>foo</td>
    </tr>
  </tbody>
</table>
</div>



```python
pd.read_csv('ex2.csv', names=['a', 'b', 'c', 'd', 'message'])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>message</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>hello</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>world</td>
    </tr>
    <tr>
      <th>2</th>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>foo</td>
    </tr>
  </tbody>
</table>
</div>


message 컬럼을 색인으로 하는 DataFrame을 반환하려면 index_col 인자에 4번째 컬럼 또는 'message' 이름을 가진 컬럼을 지정해 색인으로 만들 수 있음



```python
names = ['a', 'b', 'c', 'd', 'message']
```


```python
pd.read_csv('ex2.csv', names=names, index_col='message')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
    <tr>
      <th>message</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>hello</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>world</th>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
    <tr>
      <th>foo</th>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
    </tr>
  </tbody>
</table>
</div>


계층적 색인을 지정하고 싶다면 컬럼 번호나 이름의 리스트를 넘기면 됨



```python
parsed = pd.read_csv('csv_mindex.csv', index_col = ['key1' ,'key2'])
parsed
```

가끔 고정된 구분자 없이 공백이나 다른 패턴으로 필드를 구분해놓은 경우가 있음


241까지



```python
```
