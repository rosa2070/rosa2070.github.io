---
layout: single
title:  "데이터분석 4장 넘파이"
categories: coding
tag: [python, blog, jekyll]
toc: true
author_profile: false
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>


# 4장 NumPy 기본: 배열과 벡터 연산


Numpy : Numerical Python


- Numpy axis


→→→→→→→ axis = 1



↓



↓



↓



↓



↓



axis = 0


Numpy에서 제공하는 것들

- 효율적인 다차원 배열인 ndarray는 빠른 배열 계산과 유연한 ***브로드캐스팅*** 기능 제공

- 반복문을 작성할 필요 없이 전체 데이터 배열을 빠르게 계산할 수 있는 표준 수학 함수

- 배열 데이터를 디스크에 쓰거나 읽을 수 있는 도구와 메모리에 적재된 파일을 다루는 도구

- 선형대수, 난수 생성기, 푸리에 변환 가능

- C, C++, 포트란으로 작성한 코드를 연결 가능한 C API


백만 개의 정수를 저장하는 Numpy배열과 파이썬 리스트 비교하기



```python
import numpy as np
```


```python
my_arr = np.arange(1000000)
```


```python
my_list = list(range(1000000))
```

이제 각각의 배열과 리스트 원소에 2를 곱해보자



```python
%time for _ in range(10): my_arr2 = my_arr * 2
```

<pre>
CPU times: total: 15.6 ms
Wall time: 12.1 ms
</pre>

```python
%time for _ in range(10): my_list2 = [x*2 for x in my_list]
```

<pre>
CPU times: total: 531 ms
Wall time: 535 ms
</pre>
NumPy를 사용한 코드가 순수 파이썬으로 작성한 코드보다 열 배에서 백 배 이상 빠르고 메모리도 더 적게 사용


## 4.1 NumPy ndarray: 다차원 배열 객체


ndarray란?

- N차원의 배열 객체

- 파이썬에서 사욯라 수 있는 대규모 데이터 집합을 담을 수 있는 빠르고 유연한 자료구조


먼저 NumPy 패키지를 임포트하고 임의의 값이 들어 있는 작은 배열을 만들자



```python
import numpy as np
```


```python
#임의의 값 생성
data = np.random.randn(2,3)
```


```python
data
```

<pre>
array([[ 1.21453593, -0.11959334, -0.65202359],
       [ 0.59099795,  0.64283799, -0.99401731]])
</pre>
그리고 그 값에 산술 연산을 해보자



```python
data*10
```

<pre>
array([[12.14535928, -1.1959334 , -6.52023589],
       [ 5.90997953,  6.42837994, -9.94017311]])
</pre>

```python
data+data
```

<pre>
array([[ 2.42907186, -0.23918668, -1.30404718],
       [ 1.18199591,  1.28567599, -1.98803462]])
</pre>
첫 번째 예제는 모든 원소의 값에 10을 곱합<br>

두 번째 예제는 data 배열에서 같은 위치의 값끼리 서로 더함


ndarray : 같은 종류의 데이터를 담을 수 있는 포괄적인 다차원 배열<br>

ndarray의 모든 원소는 같은 자료형<br>

모든 배열은 ***shape***라는 튜플과 ***dtype***이라는 객체를 가짐


### data.shape

각 차원의 크기를 알려줌(몇행 몇열)



```python
data.shape
```

<pre>
(2, 3)
</pre>
### data.dtype

배열에 저장된 ***자료형***을 알려줌



```python
data.dtype
```

<pre>
dtype('float64')
</pre>
### 4.1.1 ndarray 생성


배열은 생성하는 가장 쉬운 방법 : array 함수 이용<br>

순차적인 객체(다른 배열도 포함)를 넘겨받고, 넘겨받은 데이터가 들어 있는 새로운 NumPy 배열 생성<br>

예를 들어 파이썬의 리스트는 변환하기 좋은 예


#### np.array



```python
data1 = [6,7.5,8,0,1]
```


```python
arr1 = np.array(data1)
```


```python
arr1
```

<pre>
array([6. , 7.5, 8. , 0. , 1. ])
</pre>
같은 길이를 가지는 리스트를 내포하고 있는 순차 데이터는 다차원 배열로 변환 가능



```python
data2 = [[1,2,3,4], [5,6,7,8]]
```


```python
arr2 = np.array(data2)
```


```python
arr2
```

<pre>
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])
</pre>
#### ndim

배열의 차원 수 or 배열의 축 수 


data2는 리스트를 담고 있는 리스트이므로 Numpy 배열인 arr2는 해당 데이터로부터 형태를 추론해 2차원 형태로 생성됨<br>

ndim과 shape 속성을 검사해 이를 확인 가능



```python
arr2.ndim 
```

<pre>
2
</pre>

```python
arr2.shape
```

<pre>
(2, 4)
</pre>
명시적으로 지정하지 않는 한 np.array는 생성될 때 적절한 자료형을 추론<br>

그렇게 추론된 자료형은 dtype 객체에 저장됨



```python
arr1
```

<pre>
array([6. , 7.5, 8. , 0. , 1. ])
</pre>

```python
arr1.dtype
```

<pre>
dtype('float64')
</pre>

```python
arr2
```

<pre>
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])
</pre>

```python
arr2.dtype
```

<pre>
dtype('int32')
</pre>
#### type과 dtype의 차이

dtype은 ndarray 원소의 데이터 타입을 반환<br>

type(A)은 A의 데이터 타입을 반환


np.array는 새로운 배열을 생성하기 위한 여러 함수를 가진다

- zeros와 ones: 주어진 길이나 모양에 각각 0과 1이 들어 잇는 배열 생성

- empty함수 : 초기화되지 않는 배열 생성


이런 메서드를 사용해 다차원 배열을 생성하려면 원하는 형태의 튜플을 넘기면 됨



```python
np.zeros(0)
```

<pre>
array([], dtype=float64)
</pre>

```python
np.zeros((3,6))
```

<pre>
array([[0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0.]])
</pre>

```python
np.zeros((2,3,2)) #삼차원
```

<pre>
array([[[0., 0.],
        [0., 0.],
        [0., 0.]],

       [[0., 0.],
        [0., 0.],
        [0., 0.]]])
</pre>
***CAUTION_*** np.empty는 0으로 초기화된 배열 반환 X<br>

대부분의 경우 np.empty는 초기화되지 않는 '가비지' 값으로 채워진 배열 반환


arange는 파이썬의 range 함수의 배열 버전



```python
np.arange(15)
```

<pre>
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
</pre>
#### 배열 생성 함수


NumPy는 산술 연산에 초점이 맞춰져 있기 때문에 만약 자료형을 명시하지 않으면 float64(부동소수점)가 될 것


##### array

입력 데이터(리스트, 튜플, 배열 또는 다른 순차형 데이터)를 ndarray로 변환하며<br>

dtype을 명시하지 않은 경우 자료형을 추론해 저장. <br>

기본적으로 입력데이터는 복사됨



```python
np.array([1,2,3])
```

<pre>
array([1, 2, 3])
</pre>
- upcasting(업캐스팅)



```python
np.array([1,2,3.0])
```

<pre>
array([1., 2., 3.])
</pre>

```python
np.array([[1,2],[3,4]])
```

<pre>
array([[1, 2],
       [3, 4]])
</pre>
- 배열의 최소 차원 명시



```python
np.array([1,2,3], ndmin=2)
```

<pre>
array([[1, 2, 3]])
</pre>

```python
np.array([1,2,3], dtype=complex)
```

<pre>
array([1.+0.j, 2.+0.j, 3.+0.j])
</pre>
##### asarray

입력 데이터를 ndarray로 변환하지만 입력데이터가 이미 ndarray일 경우 복사가 일어나지 않음



```python
a = [1,2]
```


```python
np.asarray(a)
```

<pre>
array([1, 2])
</pre>
- 기존 array는 복사(copy)되지 X



```python
a = np.array([1,2])
```


```python
np.asarray(a) is a
```

<pre>
True
</pre>
- dtype이 설정되어 있으면 dtype이 일치하지 않는 경우에만 배열이 복사(copy)됨



```python
a = np.array([1,2], dtype = np.float32)
```


```python
np.asarray(a, dtype=np.float32) is a
```

<pre>
True
</pre>

```python
np.asarray(a, dtype=np.float64) is a
```

<pre>
False
</pre>
##### arange

내장 range 함수와 유사하지만 리스트 대신 ndarray 반환<br>

맨 끝자리 숫자 포함 X



```python
np.arange(3)
```

<pre>
array([0, 1, 2])
</pre>

```python
np.arange(3.0)
```

<pre>
array([0., 1., 2.])
</pre>

```python
np.arange(3,7)
```

<pre>
array([3, 4, 5, 6])
</pre>

```python
np.arange(3,7,2)
```

<pre>
array([3, 5])
</pre>
##### ones, ones_like

- 주어진 dtype과 모양을 가지는 배열을 생성하고 내용을 모두 1로 초기화.<br>

ones_like는 주어진 배열과 동일한 모양(형태)과 dtype(데이터타입)을 가지는 배열을 새로 생성해 내용을 모두 1로 초기화



```python
np.ones(5)
```

<pre>
array([1., 1., 1., 1., 1.])
</pre>

```python
np.ones((5,), dtype=int)
```

<pre>
array([1, 1, 1, 1, 1])
</pre>

```python
np.ones((2,1))
```

<pre>
array([[1.],
       [1.]])
</pre>

```python
s = (2,2)
```


```python
np.ones(s)
```

<pre>
array([[1., 1.],
       [1., 1.]])
</pre>

```python
x = np.arange(6)
```


```python
x = x.reshape((2,3))
```


```python
x
```

<pre>
array([[0, 1, 2],
       [3, 4, 5]])
</pre>

```python
np.ones_like(x)
```

<pre>
array([[1, 1, 1],
       [1, 1, 1]])
</pre>

```python
y = np.arange(3, dtype = float)
```


```python
y
```

<pre>
array([0., 1., 2.])
</pre>

```python
np.ones_like(y)
```

<pre>
array([1., 1., 1.])
</pre>
##### zeros, zeros_like 

- ones, ones_like와 동일하지만 내용을 0으로 채운다



```python
np.zeros(5)
```

<pre>
array([0., 0., 0., 0., 0.])
</pre>

```python
np.zeros((5,), dtype = int)
```

<pre>
array([0, 0, 0, 0, 0])
</pre>

```python
np.zeros((2,1))
```

<pre>
array([[0.],
       [0.]])
</pre>

```python
s = (2,2)
```


```python
np.zeros(s)
```

<pre>
array([[0., 0.],
       [0., 0.]])
</pre>

```python
x = np.arange(6)
```


```python
x = x.reshape((2,3))
```


```python
x
```

<pre>
array([[0, 1, 2],
       [3, 4, 5]])
</pre>

```python
np.zeros_like(x)
```

<pre>
array([[0, 0, 0],
       [0, 0, 0]])
</pre>

```python
y = np.arange(3, dtype=float)
```


```python
y
```

<pre>
array([0., 1., 2.])
</pre>

```python
np.zeros_like(y)
```

<pre>
array([0., 0., 0.])
</pre>
##### empty, empty_like

- 메모리를 할당해 새로운 배열을 생성하지만 ones나 zeros처럼 값을 초기화하지 X



```python
np.empty([2,2])
```

<pre>
array([[0., 0.],
       [0., 0.]])
</pre>

```python
np.empty([2,2], dtype=int)
```

<pre>
array([[         0, 1072693248],
       [         0, 1073741824]])
</pre>

```python
a = ([1,2,3], [4,5,6])
```


```python
np.empty_like(a)
```

<pre>
array([[  872409520,         531,           0],
       [          0,      131074, -2147483648]])
</pre>

```python
a = np.array([[1.,2.,3.], [4.,5.,6.]])
```


```python
np.empty_like(a)
```

<pre>
array([[ 2.42907186, -0.23918668, -1.30404718],
       [ 1.18199591,  1.28567599, -1.98803462]])
</pre>
##### full, full_like

- 인자로 받은 dtype과 배열의 모양을 가지는 배열을 생성하고 인자로 받은 값으로 배열을 채운다



```python
np.full((2,2), np.inf)
```

<pre>
array([[inf, inf],
       [inf, inf]])
</pre>

```python
np.full((2,2), 10)
```

<pre>
array([[10, 10],
       [10, 10]])
</pre>

```python
np.full((2,2), [1,2])
```

<pre>
array([[1, 2],
       [1, 2]])
</pre>

```python
x = np.arange(6, dtype=int)
```


```python
x
```

<pre>
array([0, 1, 2, 3, 4, 5])
</pre>

```python
np.full_like(x,1)
```

<pre>
array([1, 1, 1, 1, 1, 1])
</pre>

```python
np.full_like(x, 0.1)
```

<pre>
array([0, 0, 0, 0, 0, 0])
</pre>

```python
np.full_like(x, 0.1, dtype=np.double)
```

<pre>
array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
</pre>

```python
np.full_like(x, np.nan, dtype=np.double)
```

<pre>
array([nan, nan, nan, nan, nan, nan])
</pre>

```python
y = np.arange(6, dtype = np.double)
y
```

<pre>
array([0., 1., 2., 3., 4., 5.])
</pre>

```python
np.full_like(y, 0.1)
```

<pre>
array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
</pre>

```python
y = np.zeros([2,2,3], dtype = int)
y
```

<pre>
array([[[0, 0, 0],
        [0, 0, 0]],

       [[0, 0, 0],
        [0, 0, 0]]])
</pre>

```python
np.full_like(y, [0,0,255])
```

<pre>
array([[[  0,   0, 255],
        [  0,   0, 255]],

       [[  0,   0, 255],
        [  0,   0, 255]]])
</pre>
##### eye, identity

- N X N 크기의 단위행렬 생성(좌상단에서 우하단을 잇는 대각선은 1로 채워지고 나머지는 0으로 채워짐)



```python
np.eye(2, dtype=int)
```

<pre>
array([[1, 0],
       [0, 1]])
</pre>

```python
np.eye(3, k=1)
```

<pre>
array([[0., 1., 0.],
       [0., 0., 1.],
       [0., 0., 0.]])
</pre>

```python
np.identity(3)
```

<pre>
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
</pre>
***np.identity()와 np.eye()의 차이***

- identity 행렬은 항상 N x N의 행렬이라면, eye는 원하는 N x M의 행렬을 만들 수 있음


### 4.1.2 ndarray의 dtype

- dtype은 ndarray가 메모리에 있는 특정 데이터를 해석하기 위해 필요한 정보(또는 ***메타데이터***)를 담고 있는 특수한 객체



```python
arr1 = np.array([1,2,3], dtype = np.float64)
```


```python
arr2 = np.array([1,2,3], dtype=np.int32)
```


```python
arr1.dtype
```

<pre>
dtype('float64')
</pre>

```python
arr2.dtype
```

<pre>
dtype('int32')
</pre>
***NumPy 자료형***


|자료형|자료형 코드|설명|

|---|---|---|

|int8, uint8|i1,u1|부호가 있는 8비트(1바이트) 정수형과 부호가 없는 8비트 정수형|

|int16, uint16|i2, u2|부호가 있는 16비트 정수형과 부호가 없는 16비트 정수형|

|int32, uint32|i4, u4|부호가 있는 32비트 정수형과 부호가 없는 32비트 정수형|

|int64, uint64|i8, u8|부호가 있는 64비트 정수형과 부호가 없는 64비트 정수형|

|float16|f2|반정밀도 부동소수점|

|float32|f4 또는 f|단정밀도 부동소수점.C언어의 float형과 호환|

|float64|f8 또는 d|배정밀도 부동소수점.C언어의 double형과 파이썬의 float 객체와 호환|

|float128|f16 또는 g|확장정밀도 부동소수점|

|complex64,|c8, c16, c32|각각 2개의 32, 64, 128비트 부동소수점형을 가지는 복소수|

|complex128,|

|complex256|

|bool|?|True와 False 값을 저장하는 불리언형|

|object|0|파이썬 객체형|

|string_|S|고정 길이 아스키 문자열형(각 문자는 1바이트). 길이가 10인 문자열 dtype은 S10이 된다|

|unicode_|U|고정 길이 유니코드형(플랫폼에 따라 문자열 바이트 수가 다르다).string_형과 같은 형식을 쓴다(예:U10)|


#### astype


ndarray의 astype 메서드를 사용해서 배열의 dtype을 다른 형으로 명시적 변환(또는 ***캐스팅***) 가능



```python
arr = np.array([1,2,3,4,5])
```


```python
arr.dtype
```

<pre>
dtype('int32')
</pre>

```python
float_arr = arr.astype(np.float64)
```


```python
float_arr.dtype
```

<pre>
dtype('float64')
</pre>
위 예제에서는 정수형을 부동소수점으로 변환함.<br>

만약 부동소수점수를 정수형 dtype으로 변환하면 소수점 아래 자리는 버려짐



```python
arr = np.array([3.7, -1.2, -2.6, 0.5, 12.9, 10.1])
```


```python
arr
```

<pre>
array([ 3.7, -1.2, -2.6,  0.5, 12.9, 10.1])
</pre>

```python
arr.astype(np.int32)
```

<pre>
array([ 3, -1, -2,  0, 12, 10])
</pre>
숫자 형식의 문자열을 담고 있는 배열이 있다면 ***astype***을 이용해 숫자로 변환 가능



```python
numeric_strings = np.array(['1.25', '-9.6', '42'], dtype=np.string_)
```


```python
numeric_strings.astype(float)
```

<pre>
array([ 1.25, -9.6 , 42.  ])
</pre>
다른 배열의 dtype 속성을 이용하는 것도 가능



```python
int_array = np.arange(10)
int_array
```

<pre>
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</pre>

```python
calibers = np.array([.22, .270, .357, .380, .44, .50], dtype = np.float64)
calibers
```

<pre>
array([0.22 , 0.27 , 0.357, 0.38 , 0.44 , 0.5  ])
</pre>

```python
int_array.astype(calibers.dtype)
```

<pre>
array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])
</pre>
dtype으로 사용할 수 있는 축약 코드도 있다



```python
empty_uint32 = np.empty(8, dtype='u4')
```


```python
empty_uint32
```

<pre>
array([         0, 2146435072,          0, 2146435072,          0,
       2146435072,          0, 2146435072], dtype=uint32)
</pre>
***NOTE_*** astype을 호출하면 새로운 dtype이 이전 dtype과 동일해도 항상 새로운 배열을 생성(데이터를 복사)


### 4.1.3 NumPy 배열의 산술 연산


배열의 중요한 특징은 for문을 작성하지 않고 데이터를 일괄 처리할 수 있다는 것.이를 ***벡터화***라고 함<br>

같은 크기의 배열 간의 산술 연산은 배열의 각 원소 단위로 적용



```python
arr = np.array([[1.,2.,3.], [4.,5.,6.]])
```


```python
arr
```

<pre>
array([[1., 2., 3.],
       [4., 5., 6.]])
</pre>

```python
arr*arr
```

<pre>
array([[ 1.,  4.,  9.],
       [16., 25., 36.]])
</pre>

```python
arr - arr
```

<pre>
array([[0., 0., 0.],
       [0., 0., 0.]])
</pre>
스칼라 인자가 포함된 산술 연산의 경우 배열 내의 모든 원소에 스칼라 인자가 적용됨



```python
1/ arr
```

<pre>
array([[1.        , 0.5       , 0.33333333],
       [0.25      , 0.2       , 0.16666667]])
</pre>

```python
arr ** 0.5
```

<pre>
array([[1.        , 1.41421356, 1.73205081],
       [2.        , 2.23606798, 2.44948974]])
</pre>
같은 크기를 가지는 배열 간의 비교 연산은 불리언 배열을 반환



```python
arr
```

<pre>
array([[1., 2., 3.],
       [4., 5., 6.]])
</pre>

```python
arr2 = np.array([[0.,4.,1.],[7.,2.,12.]])
```


```python
arr2
```

<pre>
array([[ 0.,  4.,  1.],
       [ 7.,  2., 12.]])
</pre>

```python
arr2>arr
```

<pre>
array([[False,  True, False],
       [ True, False,  True]])
</pre>
***브로드캐스팅(broadcasting)*** : 크기가 다른 배열 간의 연산


### 4.1.4 색인과 슬라이싱 기초



```python
arr = np.arange(10)
```


```python
arr
```

<pre>
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</pre>

```python
arr[5]
```

<pre>
5
</pre>

```python
arr[5:8]
```

<pre>
array([5, 6, 7])
</pre>

```python
arr[5:8] = 12
```


```python
arr
```

<pre>
array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])
</pre>
위에서 볼 수 있듯이 arr[5:8] = 12처럼 배열 조각에 스칼라값을 대입하면 12가 선택 영역 전체로 전파(또는 ***브로드캐스팅***)됨.<br>

리스트와의 중요한 차이점은 배열 조각은 원본 배열의 ***뷰***라는 점<br>

즉, 데이터는 복사되지 않고 뷰에 대한  변경은 그대로 원본 배열에 반영됨


이에 대한 예제로 먼저 arr 배열의 슬라이스를 생성해보자



```python
arr_slice = arr[5:8]
```


```python
arr_slice
```

<pre>
array([12, 12, 12])
</pre>
그리고 arr_slice의 값은 변경하면 원래 배열인 arr의 값도 바뀐다



```python
arr_slice[1] = 12345
```


```python
arr
```

<pre>
array([    0,     1,     2,     3,     4,    12, 12345,    12,     8,
           9])
</pre>
단순히 [:]로 슬라이스를 하면 배열의 모든 값을 할당



```python
arr_slice[:] = 64
```


```python
arr
```

<pre>
array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])
</pre>
***CAUTION_*** 만약 뷰 대신 ndarray 슬라이스의 복사본을 얻고 싶다면 arr[5:8].copy()를 사용해 명시적으로 배열 복사


다차원 배열을 다룰 때는 좀 더 많은 옵션이 있다. <br>

2차원 배열에서 각 색인에 해당하는 요소는 스칼라값이 아니라 1차원 배열



```python
arr2d = np.array([[1,2,3],[4,5,6],[7,8,9]])
```


```python
arr2d[2]
```

<pre>
array([7, 8, 9])
</pre>
따라서 개별 요소는 재귀적으로 접근해야 함<br>

하지만 그렇게 하기는 귀찮기 때문에 콤마로 구분된 색인 리스트를 넘기면 됨. <br>

그러므로 다음 두 표현은 동일



```python
arr2d[0][2]
```

<pre>
3
</pre>

```python
arr2d[0,2]
```

<pre>
3
</pre>
다차원 배열에서 마지막 색인을 생략하면 반환되는 객체는 상위 차원의 데이터를 포함하고 있는 한 차원 낮은 ndarray가 됨<br>

2x2x3 크기의 배열 arr3d가 있다면



```python
arr3d = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])
```


```python
arr3d
```

<pre>
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
</pre>
arr3d[0]은 2x3 크기의 배열



```python
arr3d[0]
```

<pre>
array([[1, 2, 3],
       [4, 5, 6]])
</pre>
arr3d[0]에는 스칼라값과 배열 모두 대입 가능



```python
old_values = arr3d[0].copy()
```


```python
arr3d[0] = 42
```


```python
arr3d
```

<pre>
array([[[42, 42, 42],
        [42, 42, 42]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
</pre>

```python
arr3d[0] = old_values
```


```python
arr3d
```

<pre>
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
</pre>
이런 식으로 arr3d[1,0]은 색인되는 1차원 배열과 그 값을 반환



```python
arr3d[1,0]
```

<pre>
array([7, 8, 9])
</pre>
이 표현은 다음처럼 두 번에 걸쳐 인덱싱한 결과와 동일



```python
x = arr3d[1]
```


```python
x
```

<pre>
array([[ 7,  8,  9],
       [10, 11, 12]])
</pre>

```python
x[0]
```

<pre>
array([7, 8, 9])
</pre>
여기서 살펴본 선택된 배열의 부분집합은 모두 배열의 뷰를 반환


#### 슬라이스로 선택하기


파이썬의 리스트 같은 1차원 객체처럼 ndarray는 익숙한 문법으로 슬라이싱 가능



```python
arr
```

<pre>
array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])
</pre>

```python
arr[1:6]
```

<pre>
array([ 1,  2,  3,  4, 64])
</pre>
위에서 살펴본 arr2d를 생각해보자. 이 배열을 슬라이싱하는 방법은 조금 다르다.



```python
arr2d
```

<pre>
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
</pre>

```python
arr2d[:2]
```

<pre>
array([[1, 2, 3],
       [4, 5, 6]])
</pre>
확인한 것처럼 첫 번째 축인 0번 축을 기준으로 슬라이싱됨.<br>

따라서 슬라이스는 축을 따라 선택 영역 내의 요소를 선택<br>

arr2d[:2]는 'arr2d의 시작부터 두 번째 로우까지의 선택'이라고 이해하면 쉽다


색인을 여러개 넘겨서 다차원을 슬라이싱하는 것도 가능



```python
arr2d[:2,1:]
```

<pre>
array([[2, 3],
       [5, 6]])
</pre>
이렇게 슬라이싱하면 항상 같은 차원의 배열에 대한 뷰를 얻게 됨<br>

정수 색인과 슬라이스를 함께 사용해 한 차원 낮은 슬라이스를 얻을 수 있음


예를 들어 두 번째 로우에서 처음 두 컬럼만 선택하고 싶다면 아래처럼 하면 됨



```python
arr2d[1,:2]
```

<pre>
array([4, 5])
</pre>
이와 유사하게 처음 두 로우에서 세 번째 컬럼만 선택하고 싶다면 아래처럼 하면 된다



```python
arr2d[:2, 2]
```

<pre>
array([3, 6])
</pre>

```python
arr2d[:, :1]
```

<pre>
array([[1],
       [4],
       [7]])
</pre>
물론 슬라이싱 구문에 값을 대입하면 선택 영역 전체에 값이 대입됨



```python
arr2d[:2, 1:] = 0
```


```python
arr2d
```

<pre>
array([[1, 0, 0],
       [4, 0, 0],
       [7, 8, 9]])
</pre>
### 4.1.5 불리언값으로 선택하기


중복된 이름이 포함된 배열이 있다고 하자. 그리고 numpy.random 모듈에 있는 randn 함수를 사용해서 임의의 표준 정규 분포 데이터를 생성하자.



```python
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
```


```python
data = np.random.randn(7,4)
```

***np.random.rand(p,q)***

- 0부터 1사이 균일 분포 난수를 matrix array(p,q)로 생성



```python
names
```

<pre>
array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='<U4')
</pre>

```python
data
```

<pre>
array([[-0.20809015,  0.11875437,  0.66577072,  0.83017614],
       [ 1.27080334, -0.11633043,  0.34285304, -1.87582279],
       [-1.4174403 , -0.58854514, -1.01616086,  0.27747826],
       [ 0.93217918, -0.8737107 , -1.11573614,  1.30750775],
       [ 0.09414054, -0.49775256, -0.74818969,  1.04805989],
       [ 0.56895419, -1.52078316, -0.26844013,  1.29307678],
       [-1.5023777 ,  0.4187467 , -0.83000903,  0.89202307]])
</pre>
각각의 이름은 data 배열의 각 로우에 대응한다고 가정.<br>

만약 전체 로우에서 'Bob'과 같은 이름을 선택하려면 산술 연산자 마찬가지로 배열에 대한 비교 연산(== 같은)도 벡터화되므로<br>

names를 'Bob' 문자열과 비교하면 불리언 배열을 반환



```python
names == 'Bob'
```

<pre>
array([ True, False, False,  True, False, False, False])
</pre>
이 불리언 배열은 배열의 색인으로 사용 가능



```python
data[names == 'Bob']
```

<pre>
array([[-0.20809015,  0.11875437,  0.66577072,  0.83017614],
       [ 0.93217918, -0.8737107 , -1.11573614,  1.30750775]])
</pre>
불리언 배열은 반드시 색인하려는 축의 길이와 동일한 길이를 가져야 함.<br>

불리언 배열 색인도 슬라이스나 요소를 선택하는데 짜 맞출 수 있음


***CAUTION_*** 불리언값으로 배열 선택 시에는 불리언 배열의 크기가 다르더라도 실패하지 X.<br>

따라서 이 기능을 사용할 때는 항상 주의하자.


다음 예제에서는 names == 'Bob'인 로우에서 2: 컬럼을 선택함



```python
data[names == 'Bob', 2:]
```

<pre>
array([[ 0.66577072,  0.83017614],
       [-1.11573614,  1.30750775]])
</pre>

```python
data[names=='Bob', 3]
```

<pre>
array([0.83017614, 1.30750775])
</pre>
'Bob'이 아닌 요소들을 선택하려면 != 연산자를 사용하거나 ~를 사용해서 조건절 부인



```python
names != 'Bob'
```

<pre>
array([False,  True,  True, False,  True,  True,  True])
</pre>

```python
data[~(names=='Bob')]
```

<pre>
array([[ 1.27080334, -0.11633043,  0.34285304, -1.87582279],
       [-1.4174403 , -0.58854514, -1.01616086,  0.27747826],
       [ 0.09414054, -0.49775256, -0.74818969,  1.04805989],
       [ 0.56895419, -1.52078316, -0.26844013,  1.29307678],
       [-1.5023777 ,  0.4187467 , -0.83000903,  0.89202307]])
</pre>
~ 연산자는 일반적인 조건을 반대로 쓰고 싶을 때 유용



```python
cond = names == 'Bob'
```


```python
data[~cond]
```

<pre>
array([[ 1.27080334, -0.11633043,  0.34285304, -1.87582279],
       [-1.4174403 , -0.58854514, -1.01616086,  0.27747826],
       [ 0.09414054, -0.49775256, -0.74818969,  1.04805989],
       [ 0.56895419, -1.52078316, -0.26844013,  1.29307678],
       [-1.5023777 ,  0.4187467 , -0.83000903,  0.89202307]])
</pre>
세 가지 이름 중에서 두 가지 이름을 선택하려면 &(and)나 |(or) 같은 논리 연산자를 사용한 여러 개의 불리언 조건 사용



```python
mask = (names == 'Bob') | (names == 'Will')
```


```python
mask
```

<pre>
array([ True, False,  True,  True,  True, False, False])
</pre>

```python
data[mask]
```

<pre>
array([[-0.20809015,  0.11875437,  0.66577072,  0.83017614],
       [-1.4174403 , -0.58854514, -1.01616086,  0.27747826],
       [ 0.93217918, -0.8737107 , -1.11573614,  1.30750775],
       [ 0.09414054, -0.49775256, -0.74818969,  1.04805989]])
</pre>
배열에 불리언 색인을 이용해서 데이터를 선택하면 반환되는 배열의 내용이 바뀌지 않더라도 항상 데이터 복사 발생


***CAUTION_*** 파이썬 예약어인 and와 or은 불리언 배열에서 사용불가. 대신 &(and)와 |(or) 사용


#### 불리언 배열에 값 대입


data에 저장된 모든 음수를 0으로 대입하려면 다음과 같이 한다.



```python
data[data<0] = 0
```


```python
data
```

<pre>
array([[0.        , 0.11875437, 0.66577072, 0.83017614],
       [1.27080334, 0.        , 0.34285304, 0.        ],
       [0.        , 0.        , 0.        , 0.27747826],
       [0.93217918, 0.        , 0.        , 1.30750775],
       [0.09414054, 0.        , 0.        , 1.04805989],
       [0.56895419, 0.        , 0.        , 1.29307678],
       [0.        , 0.4187467 , 0.        , 0.89202307]])
</pre>
#### 1차원 불리언 배열을 사용해 전체 로우나 컬럼 선택하기



```python
data[names != 'Joe'] = 7
```


```python
data
```

<pre>
array([[7.        , 7.        , 7.        , 7.        ],
       [1.37842243, 0.69548055, 0.01730418, 0.        ],
       [7.        , 7.        , 7.        , 7.        ],
       [7.        , 7.        , 7.        , 7.        ],
       [7.        , 7.        , 7.        , 7.        ],
       [0.        , 0.        , 0.        , 0.04893472],
       [0.        , 0.        , 0.        , 0.5133134 ]])
</pre>
### 4.1.6 팬시 색인


***팬시 색인***(fancy indexing)은 정수 배열을 사용한 색인을 설명하기 위해 NumPy에서 차용한 단어<br>


8x4 크기의 배열이 있다고 하자



```python
arr = np.empty((8,4))
arr
```

<pre>
array([[1.12721079e-311, 1.06718180e-321, 0.00000000e+000,
        0.00000000e+000],
       [0.00000000e+000, 5.02034658e+175, 7.40792794e-038,
        1.32680758e-047],
       [3.50368844e-033, 4.99799512e+174, 6.44386491e-067,
        5.19192727e-144],
       [3.59751658e+252, 1.46901661e+179, 8.37404147e+242,
        1.04918675e-153],
       [7.69165785e+218, 5.04621343e+180, 1.04917822e-153,
        9.08366793e+223],
       [7.40792794e-038, 1.32680758e-047, 3.50368844e-033,
        4.99799512e+174],
       [1.04917763e-153, 1.94918966e-153, 2.57707508e-057,
        2.26166164e-076],
       [2.00374991e-052, 2.59027896e-144, 7.79952704e-143,
        5.81186265e+294]])
</pre>

```python
for i in range(8):
    arr[i] = i
```


```python
arr
```

<pre>
array([[0., 0., 0., 0.],
       [1., 1., 1., 1.],
       [2., 2., 2., 2.],
       [3., 3., 3., 3.],
       [4., 4., 4., 4.],
       [5., 5., 5., 5.],
       [6., 6., 6., 6.],
       [7., 7., 7., 7.]])
</pre>
특정한 순서로 로우를 선택하고 싶다면 그냥 원하는 순서가 명시된 정수가 담긴 ndarray나 리스트를 넘기면 됨



```python
arr[[4,3,0,6]]
```

<pre>
array([[4., 4., 4., 4.],
       [3., 3., 3., 3.],
       [0., 0., 0., 0.],
       [6., 6., 6., 6.]])
</pre>
색인으로 음수를 사용하면 끝에서부터 로우 선택



```python
arr[[-3, -5, -7]]
```

<pre>
array([[5., 5., 5., 5.],
       [3., 3., 3., 3.],
       [1., 1., 1., 1.]])
</pre>
다차원 색인 배열을 넘기는 것은 조금 다르게 동작<br>

각각의 색인 튜플에 대응하는 1차원 배열이 선택됨



```python
arr = np.arange(32).reshape((8,4))
```


```python
arr
```

<pre>
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])
</pre>

```python
arr[[1,5,7,2],[0,3,1,2]]
```

<pre>
array([ 4, 23, 29, 10])
</pre>
위 결과를 보면 (1,0), (5,3), (7,1), (2,2)에 대응하는 원소들이 선택됨<br>

배열이 몇 차원이든지(여기서는 2차원) 팬시 색인의 결과는 항상 1차원


행렬의 행(로우)와 열(컬럼)에 대응하는 사각형 모양의 값이 선택되도록 하려면 다음처럼 하면 된다.



```python
arr[[1,5,7,2]][:, [0,3,1,2]]
```

<pre>
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])
</pre>
팬시 색인은 슬라이싱과는 달리 선택된 데이터를 새로운 배열로 복사


### 4.1.7 배열 전치와 축 바꾸기


배열 전치는 데이터를 복사하지 않고 데이터의 모양이 바뀐 뷰를 반환하는 특별한 기능<br>

ndarray는 transpose 메서드와 T라는 이름의 특수한 속성을 가짐



```python
arr = np.arange(15).reshape((3,5))
```


```python
arr
```

<pre>
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
</pre>

```python
arr.T
```

<pre>
array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])
</pre>
행렬 계산을 할 때 자주 사용하게 될 텐데, 예를 들어 행렬의 내적은 np.dot을 이용해 구할 수 있다



```python
arr = np.random.randn(6,3)
```


```python
arr
```

<pre>
array([[ 0.19040053,  0.92430505,  0.6302953 ],
       [ 0.70535042,  1.61050262,  1.38356721],
       [ 1.50016598,  0.65993566, -0.18507174],
       [-0.84584085, -0.19502979, -0.71692132],
       [ 0.05620176,  0.13699709,  0.86767426],
       [ 0.67863369, -1.89756431,  0.79245034]])
</pre>

```python
np.dot(arr.T, arr)
```

<pre>
array([[3.96341861, 1.18688247, 2.01121961],
       [1.18688247, 7.54112872, 1.44365268],
       [2.01121961, 1.44365268, 4.24059428]])
</pre>
다차원 배열의 경우 transpose 메서드는 튜플로 축 번호를 받아서 치환



```python
arr = np.arange(16).reshape((2,2,4))

arr
```

<pre>
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
</pre>

```python
arr.transpose((1,0,2))
```

<pre>
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])
</pre>
이 예제에서 첫 번째(0)와 두 번째(1)의 축 순서가 뒤바뀌었고 마지막 축(2)은 그대로 남았다.


#### 3차원 배열 transpose


shape가 (2,3,4)인 배열을 하나 정의하자. 



```python
a = np.arange(24).reshape(2,3,4)
```


```python
a
```

<pre>
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])
</pre>
T메소드를 적용해보자



```python
a.T
```

<pre>
array([[[ 0, 12],
        [ 4, 16],
        [ 8, 20]],

       [[ 1, 13],
        [ 5, 17],
        [ 9, 21]],

       [[ 2, 14],
        [ 6, 18],
        [10, 22]],

       [[ 3, 15],
        [ 7, 19],
        [11, 23]]])
</pre>

```python
a.T.shape
```

<pre>
(4, 3, 2)
</pre>
배열 모양이 (2,3,4)에서 (4,3,2)로 바뀐 것을 알 수 있다


transpose 메소드를 적용해 보자



```python
a.transpose((2,1,0))
```

<pre>
array([[[ 0, 12],
        [ 4, 16],
        [ 8, 20]],

       [[ 1, 13],
        [ 5, 17],
        [ 9, 21]],

       [[ 2, 14],
        [ 6, 18],
        [10, 22]],

       [[ 3, 15],
        [ 7, 19],
        [11, 23]]])
</pre>
괄호 안에 입력한 것은 axis 번호다.<br>

기존 shape인 (2,3,4)는 각각 axis 0,1,2에 매칭되어 있었다.<br>

기존 axis는 아래와 같다.



```python
axis0 = 2
axis1 = 3
axis2 = 4
```

새로 입력한 (2,1,0)은 순서를 아래와 같이 바꾼다는 것을 의미한다<br>

axis 뒤에 붙은 숫자를 잘 보면 이해가 될거다



```python
axis2 = 4
axis1 = 3
axis0 = 2
```

따라서 shape이 (4,3,2)로 바뀐 것이다.



```python
a.transpose((2,1,0)).shape
```

<pre>
(4, 3, 2)
</pre>
이번에는 a를 axis (1,2,0)으로 transpose해보자



```python
axis1=3
axis3=4
axis0=2
```

위와 같이 바뀔테니 , shape이 (3,4,2)가 될것이다



```python
a.transpose((1,2,0))
```

<pre>
array([[[ 0, 12],
        [ 1, 13],
        [ 2, 14],
        [ 3, 15]],

       [[ 4, 16],
        [ 5, 17],
        [ 6, 18],
        [ 7, 19]],

       [[ 8, 20],
        [ 9, 21],
        [10, 22],
        [11, 23]]])
</pre>

```python
a.transpose((1,2,0)).shape
```

<pre>
(3, 4, 2)
</pre>
T 속성을 이용하는 간단한 전치는 축을 뒤바꾸는 특별한 경우<br>

ndarray에는 swapaxes라는 메서드가 있는데 두 개의 축 번호를 받아서 배열을 뒤바꾼다



```python
arr
```

<pre>
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
</pre>

```python
arr.shape
```

<pre>
(2, 2, 4)
</pre>

```python
arr.swapaxes(1,2)
```

<pre>
array([[[ 0,  4],
        [ 1,  5],
        [ 2,  6],
        [ 3,  7]],

       [[ 8, 12],
        [ 9, 13],
        [10, 14],
        [11, 15]]])
</pre>

```python
arr.swapaxes(1,2).shape
```

<pre>
(2, 4, 2)
</pre>
배열 모양이 (2,2,4)에서 (2,4,2)로 바뀌었다


swapaxes도 마찬가지로 데이터를 복사하지 않고 원래 데이터에 대한 뷰를 반환


## 4.2 유니버설 함수 : 배열의 각 원소를 빠르게 처리하는 함수


유니버설 함수(ufunc) : ndarray 안에 있는 데이터 원소별로 연산을 수행하는 함수<br>

유니버설 함수는 하나 이상의 스칼라값을 받아서 하나 이상의 스칼라 결괏값을 반환하는 간단한 함수를<br>

고속으로 수행할 수 있는 벡터화된 래퍼 함수


많은 ufunc는 sqrt나 exp 같은 간단한 변형을 전체 원소에 적용 가능



```python
arr = np.arange(10)
```


```python
arr
```

<pre>
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</pre>

```python
np.sqrt(arr)
```

<pre>
array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
       2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])
</pre>

```python
np.exp(arr)
```

<pre>
array([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01,
       5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03,
       2.98095799e+03, 8.10308393e+03])
</pre>
***단항*** 유니버설 함수 : 위 함수들(sqrt, exp),<br>

***이항*** 유니버설 함수 : add나 maximum처럼 2개의 인자를 취해서 단일 배열을 반환하는 함수



```python
x = np.random.randn(8)
```


```python
y = np.random.randn(8)
```


```python
x
```

<pre>
array([ 0.50067454, -2.82957779,  0.08288871,  0.74368174, -0.23381051,
       -0.01337439, -2.11709125,  0.65496476])
</pre>

```python
y
```

<pre>
array([-0.64584576, -1.45001946,  0.10981863, -0.20654979, -0.56905214,
       -0.75103004, -1.28887565, -0.38420738])
</pre>

```python
np.maximum(x,y)
```

<pre>
array([ 0.50067454, -1.45001946,  0.10981863,  0.74368174, -0.23381051,
       -0.01337439, -1.28887565,  0.65496476])
</pre>
여기서 numpy.maximum은 x와 y의 원소별로 가장 큰 값 계산


여러 개의 배열을 반환하는 유니버설 함수도 있다<br>

modf는 파이썬 내장 함수인 divmod의 벡터화 버전인데, 분수를 받아서 몫과 나머지를 함께 반환



```python
arr = np.random.randn(7)*5
```


```python
arr
```

<pre>
array([-3.46705323, -0.9477356 , -1.79647916, -1.59856621, -2.60052827,
        0.4482321 ,  3.23382914])
</pre>

```python
remainder, whole_part = np.modf(arr)
```


```python
remainder # 소수부분
```

<pre>
array([-0.46705323, -0.9477356 , -0.79647916, -0.59856621, -0.60052827,
        0.4482321 ,  0.23382914])
</pre>

```python
whole_part #정수부분
```

<pre>
array([-3., -0., -1., -1., -2.,  0.,  3.])
</pre>
유니버설 함수는 선택적으로 out 인자(두 번째 매개변수)를 취해 계산 결과 따로 저장 가능



```python
arr
```

<pre>
array([-3.46705323, -0.9477356 , -1.79647916, -1.59856621, -2.60052827,
        0.4482321 ,  3.23382914])
</pre>

```python
np.sqrt(arr)
```

<pre>
C:\Users\user\AppData\Local\Temp\ipykernel_12448\2296558006.py:1: RuntimeWarning: invalid value encountered in sqrt
  np.sqrt(arr)
</pre>
<pre>
array([       nan,        nan,        nan,        nan,        nan,
       0.66950138, 1.79828505])
</pre>

```python
np.sqrt(arr, arr)
```

<pre>
C:\Users\user\AppData\Local\Temp\ipykernel_12448\269955669.py:1: RuntimeWarning: invalid value encountered in sqrt
  np.sqrt(arr, arr)
</pre>
<pre>
array([       nan,        nan,        nan,        nan,        nan,
       0.66950138, 1.79828505])
</pre>

```python
arr
```

<pre>
array([       nan,        nan,        nan,        nan,        nan,
       0.66950138, 1.79828505])
</pre>
참고 블로그 : https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=sooftware&logNo=221575467290


### 단항 유니버셜 함수


#### abs, fabs


각 원소(정수, 부동소수점수, 복소수)의 절댓값을 구함.<br>

복소수가 아닌 경우에는 빠른 연산을 위해 fabs 사용



```python
data = np.arange(-5, 6)
```


```python
data
```

<pre>
array([-5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5])
</pre>

```python
np.abs(data)
```

<pre>
array([5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5])
</pre>

```python
np.fabs(data)
```

<pre>
array([5., 4., 3., 2., 1., 0., 1., 2., 3., 4., 5.])
</pre>
np.abs()는 정수형, np.fabs()는 float형으로 반환한다는 차이가 있다


#### sqrt

각 원소의 제곱근 계산. arr ** 0.5와 동일



```python
test_value = np.sqrt(1)
print(test_value)
```

<pre>
1.0
</pre>

```python
test_value = np.sqrt(4)
print(test_value)
```

<pre>
2.0
</pre>

```python
test_value = np.sqrt(9)
print(test_value)
```

<pre>
3.0
</pre>
#### square

각 원소의 제곱 계산. arr ** 2와 동일



```python
a = np.square(1.5)
a
```

<pre>
2.25
</pre>

```python
b = np.square([1,2,3])
b
```

<pre>
array([1, 4, 9])
</pre>
#### exp 

각 원소에서 지수(e^x) 계산


#### log, log10, log2, log1p

각각 자연로그, 로그10, 로그2, 로그(1+x)


#### sign

각 원소의 부호 계산. 1(양수), 0(영), -1(음수)



```python
data = np.arange(-5, 6)
data
```

<pre>
array([-5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5])
</pre>

```python
np.sign(data)
```

<pre>
array([-1, -1, -1, -1, -1,  0,  1,  1,  1,  1,  1])
</pre>
#### ceil

각 원소의 소수자리를 올린다. 각 원소의 값보다 같거나 큰 정수 중 가장 작은 정수 반환



```python
np.ceil(5)
```

<pre>
5.0
</pre>

```python
np.ceil(5.7928)
```

<pre>
6.0
</pre>

```python
np.ceil(5.228)
```

<pre>
6.0
</pre>

```python
np.ceil(-5.7928)
```

<pre>
-5.0
</pre>

```python
np.ceil(-5.228)
```

<pre>
-5.0
</pre>
#### floor 

각 원소의 소수자리를 내린다. 각 원소의 값보다 작거나 같은 정수 중 가장 작은 수 반환



```python
np.floor(5)
```

<pre>
5.0
</pre>

```python
np.floor(5.7928)
```

<pre>
5.0
</pre>

```python
np.floor(5.228)
```

<pre>
5.0
</pre>

```python
np.floor(-5.7928)
```

<pre>
-6.0
</pre>

```python
np.floor(-5.228)
```

<pre>
-6.0
</pre>
#### rint

각 원소의 소수자리를 반올림. dtype은 유지



```python
np.rint([-6, -4.9, -3.8, -2.7, -1.6, -0.5, 0.6, 1.7, 2.8, 3.9, 5.])
```

<pre>
array([-6., -5., -4., -3., -2., -0.,  1.,  2.,  3.,  4.,  5.])
</pre>
#### modf

각 원소의 몫과 나머지를 각각의 배열로 반환<br>

fraction(소수 부분)과 integer(정수 부분)을 따로 return



```python
np.modf([-6, -4.9, -3.8, -2.7, -1.6, -0.5, 0.6, 1.7, 2.8, 3.9, 5.])
```

<pre>
(array([-0. , -0.9, -0.8, -0.7, -0.6, -0.5,  0.6,  0.7,  0.8,  0.9,  0. ]),
 array([-6., -4., -3., -2., -1., -0.,  0.,  1.,  2.,  3.,  5.]))
</pre>
#### isnan

각 원소가 숫자가 아닌지(NaN, Not a Number)를 나타내는 불리언 배열 반환



```python
a = np.array([0,1,2,3,4])
b = np.array([0,1,1,1,1])
c = a/b
c
```

<pre>
C:\Users\user\AppData\Local\Temp\ipykernel_10632\1511146275.py:3: RuntimeWarning: invalid value encountered in divide
  c = a/b
</pre>
<pre>
array([nan,  1.,  2.,  3.,  4.])
</pre>

```python
np.isnan(c)
```

<pre>
array([ True, False, False, False, False])
</pre>
#### isfinite, isinf

각각 배열의 각 원소가 유한한지(non-int, non-NaN) 무한한지 나타내는 불리언 배열 반환



```python
np.isfinite(1)
```

<pre>
True
</pre>

```python
np.isfinite(0)
```

<pre>
True
</pre>

```python
np.isfinite(np.nan)
```

<pre>
False
</pre>

```python
np.isfinite(np.inf)
```

<pre>
False
</pre>

```python
np.isfinite(np.NINF) # NINF는 음의 무한대(-inf)
```

<pre>
False
</pre>

```python
np.isinf(1)
```

<pre>
False
</pre>

```python
np.isinf(0)
```

<pre>
False
</pre>

```python
np.isinf(np.nan)
```

<pre>
False
</pre>

```python
np.isinf(np.inf)
```

<pre>
True
</pre>

```python
np.isinf(np.NINF)
```

<pre>
True
</pre>
#### cos, cosh, sin, sinh, tan, tanh

일반 삼각함수와 쌍곡삼각함수


#### arccos, arccosh, arcsin, arcsinh, arctan, arctanh

역삼각함수


#### logical_not

각 원소의 논리 부정(not) 값을 계산. ~arr과 동일



```python
np.logical_not(3)
```

<pre>
False
</pre>

```python
np.logical_not([True, False, 0, 1])
```

<pre>
array([False,  True,  True, False])
</pre>

```python
x = np.arange(5)
x
```

<pre>
array([0, 1, 2, 3, 4])
</pre>

```python
np.logical_not(x<3)
```

<pre>
array([False, False, False,  True,  True])
</pre>
### 이항 유니버설 함수


#### add

두 배열에서 같은 위치의 원소끼리 더함



```python
a = np.array([1,2,3])
b = np.array([4,5,6])
```

<pre>
array([1, 2, 3])
</pre>

```python
a
```

<pre>
array([1, 2, 3])
</pre>

```python
b
```

<pre>
array([4, 5, 6])
</pre>

```python
c = np.add(a,b)
```


```python
c
```

<pre>
array([5, 7, 9])
</pre>
#### subtract

첫 번째 배열의 원소에서 두 번째 배열의 원소를 뺀다



```python
c = np.subtract(a,b)
c
```

<pre>
array([-3, -3, -3])
</pre>
#### multiply

배열의 원소끼리 곱함



```python
c = np.multiply(a,b)
c
```

<pre>
array([ 4, 10, 18])
</pre>
#### divide, floor_divide

첫 번째 배열의 원소를 두 번째 배열의 원소로 나눈다<br>

floor_divide는 몫만 취함



```python
c = np.divide(a,b)
c
```

<pre>
array([0.25, 0.4 , 0.5 ])
</pre>

```python
c = np.floor_divide(a,b)
c
```

<pre>
array([0, 0, 0])
</pre>
#### power

첫 번째 배열의 원소를 두 번째 배열의 원소만큼 제곱



```python
np.power([1,2,3,4], 2)
```

<pre>
array([ 1,  4,  9, 16], dtype=int32)
</pre>

```python
np.power([1,2,3,4], 0.5)
```

<pre>
array([1.        , 1.41421356, 1.73205081, 2.        ])
</pre>

```python
np.power([1.,2.,3.,4.], -1)
```

<pre>
array([1.        , 0.5       , 0.33333333, 0.25      ])
</pre>

```python
np.power([1,3,5,7], 3)
```

<pre>
array([  1,  27, 125, 343], dtype=int32)
</pre>
#### maximum, fmax

각 배열의 두 원소 중 큰 값을 반환. fmax는 Nan을 무시



```python
arr1 = np.arange(10)
arr1
```

<pre>
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</pre>

```python
arr2 = np.arange(9,-1,-1)
arr2
```

<pre>
array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])
</pre>

```python
np.maximum(arr1, arr2)
```

<pre>
array([9, 8, 7, 6, 5, 5, 6, 7, 8, 9])
</pre>

```python
arr1 = np.array([1,2,3,np.nan, 4,5,6,7,8,9])
arr1
```

<pre>
array([ 1.,  2.,  3., nan,  4.,  5.,  6.,  7.,  8.,  9.])
</pre>

```python
arr2 = np.array([9,8,7,6,5,4,np.nan, 3,2,1])
arr2
```

<pre>
array([ 9.,  8.,  7.,  6.,  5.,  4., nan,  3.,  2.,  1.])
</pre>

```python
np.fmax(arr1, arr2)
```

<pre>
array([9., 8., 7., 6., 5., 5., 6., 7., 8., 9.])
</pre>
#### minimum, fmin

각 배열의 두 원소 중 작은 값을 반환.fmin은 NaN을 무시



```python
arr1 = np.arange(10)
arr1
```

<pre>
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</pre>

```python
arr2 = np.arange(9,-1,-1)
arr2
```

<pre>
array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])
</pre>

```python
np.minimum(arr1, arr2)
```

<pre>
array([0, 1, 2, 3, 4, 4, 3, 2, 1, 0])
</pre>

```python
arr1 = np.array([1,2,3,np.nan, 4,5,6,7,8,9])
arr1
```

<pre>
array([ 1.,  2.,  3., nan,  4.,  5.,  6.,  7.,  8.,  9.])
</pre>

```python
arr2 = np.array([9,8,7,6,5,4,np.nan, 3,2,1])
arr2
```

<pre>
array([ 9.,  8.,  7.,  6.,  5.,  4., nan,  3.,  2.,  1.])
</pre>

```python
np.fmin(arr1, arr2)
```

<pre>
array([1., 2., 3., 6., 4., 4., 6., 3., 2., 1.])
</pre>
#### mod

첫 번째 배열의 원소를 두 번째 배열의 원소로 나눈 나머지를 구함



```python
arr1 = np.array([1,5,10,15,20])
arr1
```

<pre>
array([ 1,  5, 10, 15, 20])
</pre>

```python
arr2 = np.array([1,2,3,4,5])
arr2
```

<pre>
array([1, 2, 3, 4, 5])
</pre>

```python
np.mod(arr1, arr2)
```

<pre>
array([0, 1, 1, 3, 0])
</pre>
#### copysign

첫 번째 배열의 원소의 기호를 두 번째 배열의 원소의 기호로 바꿈



```python
np.copysign([-5,5,-5,5],[1,-1,1,-1])
```

<pre>
array([ 5., -5.,  5., -5.])
</pre>
#### greater, greater_equal, less, less_equal, equal, not_equal

각각 두 원소 간의 >, >=, <, <=, ==, != 비교 연산 결과를 불리언 배열로 반환



```python
np.greater([4,2], [2,2])
```

<pre>
array([ True, False])
</pre>

```python
a = np.array([4,2])
b = np.array([2,2])
a > b
```

<pre>
array([ True, False])
</pre>
#### logical_and, logical_or, logical_xor

각각 두 원소 간의 &, |, ^ 논리 연산 결과 반환


실습에 사용할 배열 a1 만들기



```python
a1 = np.array ([
    [1,2,3],
    [4,5,6]
])
```

x1은 a1 배열에서 2의 배수인 수만 True<br>

x2는 a2 배열에서 4보다 큰 수만 True



```python
x1 = a1 %2 == 0
x2 = a1 >= 4
```


```python
x1
```

<pre>
array([[False,  True, False],
       [ True, False,  True]])
</pre>

```python
x2
```

<pre>
array([[False, False, False],
       [ True,  True,  True]])
</pre>
x1과 x2의 논리곱 구하기. 모두 True면 True, 이외는 False



```python
np.logical_and(x1, x2)
```

<pre>
array([[False, False, False],
       [ True, False,  True]])
</pre>
x1과 x2의 논리합 구하기. 둘 중 하나라도 True이면 True



```python
np.logical_or(x1, x2)
```

<pre>
array([[False,  True, False],
       [ True,  True,  True]])
</pre>
XOR(exclusive or, 배타적 논리합) 구하기.<br>

1개만 참일 때, (True, False) 또는 (False, True)인 경우 True



```python
np.logical_xor(x1, x2)
```

<pre>
array([[False,  True, False],
       [False,  True, False]])
</pre>
## 4.3 배열을 이용한 배열지향 프로그래밍


NumPy 배열을 사용하면 반복문을 작성하지 않고 간결한 배열 연산을 사용해 많은 종류의 데이터 처리 작업 가능<br>

벡터화 : 배열 연산을 사용해 반복문을 명시적으로 제거하는 기법<br>

일반적으로 벡터화된 배열에 대한 산술 연산은 순수 파이썬 연산에 비해 2~3배에서 많게는 수십, 수백 배까지 빠르다<br>

부록 A에서 다룰 ***브로드캐스팅***은 아주 강력한 벡터 연산 방법 


간단한 예로 값이 놓여 있는 그리드에서 sqrt(x^2 + y^2)을 계산한다고 하자.<br>

np.meshgrid 함수는 두 개의 1차원 배열을 받아서 가능한 모든 (x, y) 짝을 만들 수 있는 2차원 배열 두 개를 반환



```python
points = np.arange(-5, 5, 0.01) # -5부터 4.99까지 0.01씩 증가하는 값들의 배열
```


```python
xs, ys = np.meshgrid(points, points)
```


```python
xs
```

<pre>
array([[-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       ...,
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99]])
</pre>

```python
ys
```

<pre>
array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
       [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
       [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
       ...,
       [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
       [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
       [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])
</pre>
이제 그리드 상의 두 포인트로 간단히 계산 적용 



```python
z = np.sqrt(xs ** 2 + ys **2) # sqrt는 제곱근 계산
```


```python
z
```

<pre>
array([[7.07106781, 7.06400028, 7.05693985, ..., 7.04988652, 7.05693985,
        7.06400028],
       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
        7.05692568],
       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
        7.04985815],
       ...,
       [7.04988652, 7.04279774, 7.03571603, ..., 7.0286414 , 7.03571603,
        7.04279774],
       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
        7.04985815],
       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
        7.05692568]])
</pre>
matplotlib을 이용해 이 2차원 배열을 시각화 가능



```python
import matplotlib.pyplot as plt
```


```python
plt.imshow(z, cmap=plt.cm.gray); plt.colorbar()
plt.title("Image plot of $\sqrt{x^2 + y^2}$ for a grid of values")
```

<pre>
Text(0.5, 1.0, 'Image plot of $\\sqrt{x^2 + y^2}$ for a grid of values')
</pre>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAecAAAG9CAYAAAAvGL7FAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy88F64QAAAACXBIWXMAAA9hAAAPYQGoP6dpAACwTUlEQVR4nO29ebheRZXvv06mk4GcSALJIRAg2GmmgECCYZKhmUTCIN2gjGG494oMEsMgiC2BlgShG0HQ2HjpRI10aC+DgDIkKkGaKQZRCAqiEQI3MYghCRASkuzfH/z2e+vUWWvVWlW1p5P6Ps/7vHtXrVq19n7fd3/2qtp7v21ZlmWQlJSUlJSUVBv1qjqApKSkpKSkpK5KcE5KSkpKSqqZEpyTkpKSkpJqpgTnpKSkpKSkminBOSkpKSkpqWZKcE5KSkpKSqqZEpyTkpKSkpJqpgTnpKSkpKSkminBOSkpKSkpqWZKcE5KSkpKSqqZEpyTkpKSkpJqpgTnpKSkpKSkmqlP1QEkJRWh999/HwYMGFB1GJUq/adNUlJzleCc1CP1r//6r/Dkk0/CPvvsU3UoSUlJSWqlYe2kHqlnnnkGJkyYUHUYSUlJSV5KcE7qcVq2bBl0dnZCW1tb1aEkJSUleSnBOanH6f7774eJEydWHUZSUlKStxKck3qc5s2bB4cffrhX27Vr18JZZ50Fo0aNgo6ODthnn33giSeeiByhn+ocW1JSUlwlOCf1KL333nvQ1tbmfaX2+vXrYfTo0fDf//3f8Pbbb8PnP/95OPbYY+G9996LHGnPii0pKSmu2rJ0v0VSD9J9990Hy5cvh//xP/5HNJ9Dhw6FX/ziF/Cxj30sms9YqnNsSUlJ/kqZc1KP0gMPPBB1vvn3v/89rFmzBj760Y9G8xlLdY4tKSkpTD0ezrNmzYK2tjb41a9+VXUolSvfF3/+85/VbZ944gmYOnUqvP3229HjuvPOO2HXXXeFAQMGQFtbGzz33HNefrIsgzfffBM6OzujxPXee+/B6aefDl/5yldgs802i+Izlnxji7WvmyLNd37q1KnRr/Cvan+H/NaT6qEeD+ekOHriiSfg6quvjg7nN998E04//XT46Ec/Cg899BA8+eST8Pd///devp5++mnYe++9o8T1wQcfwEknnQS77LILfPnLX1a1Pfjgg+HMM8+MEgcm39hi7uum6Oijj4Ynn3wSttpqq9L73hT3d1I8JTgnVaqXX34ZPvjgAzjttNPgoIMOgn322QcGDhzo5ev++++HY445Bq1bunQpbLbZZvDZz362S/kDDzwAffv2hSuvvLJVtnHjRjjjjDOgd+/ecPvttxd+v/QJJ5wA22yzTbfy9evXwx577NHlyvOQ2GLu61x1vRgtj2vLLbeEffbZB9rb20uPoYj9nbTpaJODcz509dvf/hZOPPFEGDJkCAwdOhSmTJkC69evh5deegk++clPwuDBg2H77beH66+/vkv7V155Bc466ywYM2YMDBw4ELbeems45phj4Pnnn+/W149//GPYfffdob29HXbYYQe4+eabyaGzP/zhD3DKKafA8OHDob29HXbeeWf41re+Jd6eX//613DCCSdAR0cHDBkyBE477TR48803Rfvk8ccfh0MPPRQGDx4MAwcOhP322w9+8pOfdOnj0ksvBQCA0aNHQ1tbG7S1tcGjjz4a5PfMM8+EAw44AAAAPvOZz0BbWxscfPDBrM/58+fDUUcdhda98MILsNtuu6F1W221FVx22WXwX//1X7Bw4UIAAHj00UfhxBNPhM9//vNw7bXXtmw/97nPwdKlS+HOO++EPn2Kf8LtgQceCG+88Qa8+uqrXcpvvPFG+P3vfw/f/va3g2Nz7WvXZwXw/75rzz77LPzTP/0TbL755ux8t+a3QknyG+LiooZ3f/KTn8Aee+wB7e3tMHr0aPjXf/1XcUySfaX5bt97773Q1tYGP/vZz7rVzZgxo3W8Agjbp2eeeSZsv/323cqxY5LkePTmm2/C//pf/wtGjRoF7e3tsOWWW8L+++8P8+bNc8aSJFDWwzVz5swMALIFCxZkWZZlV111VQYA2Y477pj9y7/8SzZ37tzssssuywAgu+CCC7Kddtop++Y3v5nNnTs3O+usszIAyO66666Wv/nz52cXX3xx9n/+z//J5s+fn91zzz3Z8ccfnw0YMCD7/e9/37J78MEHs169emUHH3xwds8992Q/+tGPsgkTJmTbb799Zu/2RYsWZUOGDMl222237Pvf/372yCOPZBdffHHWq1evbOrUqez25duz3XbbZZdeemn28MMPZzfeeGM2aNCgbM8998zWrVvXbV8sXry4Vfboo49mffv2zcaNG5fdeeed2b333psdccQRWVtbWzZnzpwsy7JsyZIl2YUXXpgBQHb33XdnTz75ZPbkk09mK1euJOOS+H3llVeyb33rWxkAZNOmTcuefPLJbNGiRaTPp59+OvvsZz+bAUD2yiuvdKn705/+lF100UXsvnr33XezkSNHZoceemj2zDPPZIMHD87OOuusbOPGjS2bP//5zxkAZP37988GDRrUej322GOoz40bN2YffPBBl9eBBx6YnXHGGd3KKS1cuDADgOyOO+7osj0DBw7MrrnmGu/YTHH7WvJZZVnX79qXvvSlbO7cudm9995L9in9rVCS/oa4uLDv/Lx587LevXtnBxxwQHb33XdnP/rRj7K9994723bbbbv9Nm1J95Xmu/3BBx9kw4cPz0499dRudR//+MezvfbaS71Pse2eNGlStt1223XrI99/uaTHoyOPPDLbcssts9tuuy179NFHs3vvvTf76le/2mU/JPlrk4Xzv/3bv3Wx22OPPVrwyfXBBx9kW265ZXbCCSeQ/tevX5+tW7cuGzNmTPbFL36xVb733ntno0aNytauXdsqW716dTZs2LBuB4Ajjzwy22abbbrB7oILLsj69++f/e1vfyP7z7fH7DvLsuyHP/xhBgDZ7Nmzu+0L8we7zz77ZMOHD89Wr17dZZvGjh2bbbPNNi1w3XDDDd3acpL6/cUvfpEBQPajH/1I5DfLsmzHHXfs9vnddNNN2bx585xt/+M//iMDgGzQoEHZSSedlK1fv17cL6Y8fsmL2ncbNmzIOjo6svPPP79VduSRR2Y77rhjl+9PqKh9Lf2s8u/aV7/6Va/+qd8KJelviIsL+85PmDAhGzlyZLZmzZpW2apVq7KhQ4c64SzdV1mm+25PmTIlGzBgQPb222+3yl588cUMALJbbrmFbEft0xA4S49Hm222WTZ58mTntiX5aZMb1s5l326z8847Q1tbW5ch0z59+sDf/d3fdRluXL9+PUybNg122WUX6NevH/Tp0wf69esHf/jDH+B3v/sdAAC8++678Ktf/QqOP/546NevX6vtZptt1m1O9P3334ef/exn8OlPfxoGDhwI69evb70+9alPwfvvvw9PPfWUc3tOPfXULusnnXQS9OnTB37xi1+Qbd599114+umn4Z/+6Z+6XPHbu3dvOP300+H111+Hl156ydl3WX5zHXfccfDjH/+4S9ljjz0GBx54oLNtfkFOW1sbzJo1C3r37u0dBwDAuHHjYMGCBV1ee+21F0ycOLFb+ciRI1EfvXr1gv3226/1tK8f/vCH8PDDD8N3vvOdLt+fIuTzWf3jP/6jyLfkt8LFJf0NaeJ69913YcGCBXDCCSdA//79W+WDBw8m/Zpti/pen3322bBmzRq48847W2UzZ86E9vZ2OOWUU1plIftUIs3x6OMf/zjMmjULvva1r8FTTz0FH3zwQXD/Sf9Pmyychw4d2mW9X79+MHDgwC4/2Lz8/fffb61PmTIF/vmf/xmOP/54uP/+++Hpp5+GBQsWwMc+9jFYs2YNAACsWLECsiyDESNGdOvXLnvrrbdg/fr1cMstt0Dfvn27vD71qU8BAMBf//pX5/bYtw/16dMHhg0bBm+99RbZJo8Tu5I1BwnXvmy/uY477jj47//+75aPlStXwmabbQZ9+/Zl2z333HMwceJE2H///eGdd96B//iP//COIdfgwYNh/PjxXV6DBw+GYcOGdSvnQHvggQfCb3/7W3jttddgypQpMGnSJOf8ewz5fFbSK58lvxVXXJLfkCauFStWwMaNG9Hb7Vy34BX5vd51111h7733hpkzZwIAwIYNG2D27Nlw3HHHdTlWhexTiTTHozvvvBMmTZoE//t//2/Yd999YejQoXDGGWfAsmXLguNISv/nrNbs2bPhjDPOgGnTpnUp/+tf/wof+chHAABg8803h7a2NvjLX/7Srb39xd18881bZ97nn38+2ufo0aOdcS1btgy23nrr1vr69evhrbfegmHDhpFtNt98c+jVqxcsXbq0W93//b//FwAAtthiC2ffZfnNtc8++8CwYcPggQcegEmTJsGDDz4In/zkJ9k2L730Ehx55JGw7777wo9//GM48cQTYerUqXDaaafBkCFDvGOJpQMPPBA2bNgAEydOhA0bNqguUAqRz2clvUJc8lvh4pL+hjRx5X4xHy6oFP29Puuss+C8886D3/3ud/CnP/0Jli5dCmeddVYXm5B92r9/f1i7dm23cvPkX3M82mKLLeCmm26Cm266CV577TW477774PLLL4fly5fDQw89JNnkJEabbObsq7a2tm63ZfzkJz+BN954o7U+aNAgGD9+PNx7772wbt26Vvk777wDDzzwQJe2AwcOhEMOOQR+/etfw+67794t2xo/fjwL2Fw//OEPu6z/13/9F6xfv57NvgYNGgQTJkyAu+++u8tZ98aNG2H27NmwzTbbtIaB822WnJ1r/PqoV69ecMwxx7SGth988EHyCm4AgD//+c9w2GGHwY477gh33XUX9O3bF6677jpYsWJFt4NcVdp7771hwIAB8Pzzz8MNN9wQdJDXqMjPSvJb4eKS/oY0GjRoEHz84x+Hu+++u8uI2OrVq+H+++93ti3ye33yySdD//79YdasWTBr1izYeuut4YgjjuhiE7JPt99+e1i+fHmXE55169bBww8/3Fr3PR5tu+22cMEFF8Dhhx8Ozz77rHbTkxClzFmpiRMnwqxZs2CnnXaC3XffHRYuXAg33HBDt/tUr7nmGjj66KPhyCOPhIsuugg2bNgAN9xwA2y22Wbwt7/9rYvtzTffDAcccAB84hOfgM9//vOw/fbbw+rVq+GVV16B+++/H37+858747r77ruhT58+cPjhh8OiRYvgn//5n+FjH/sYnHTSSWy76dOnw+GHHw6HHHIIXHLJJdCvXz/49re/DS+88AL853/+ZysbyW9Ruvnmm2HSpEnQt29f2HHHHWHw4MFBfn113HHHwcknnwzvvPMOvPfee2TWsHTpUjjssMNg+PDh8MADD7T+EGOnnXaCs88+G26++ebWPq9SvXr1gs033xzGjx9f6ANMMBX1WUl/K5Q0vyGN/uVf/gU++clPwuGHHw4XX3wxbNiwAb7+9a/DoEGDnH6L/F5/5CMfgU9/+tMwa9YsePvtt+GSSy6BXr265k8h+/Qzn/kMfPWrX4XPfvazcOmll8L7778P3/zmN2HDhg1d7CTHo5UrV8IhhxwCp5xyCuy0004wePBgWLBgATz00ENwwgkneO+DJENVXo1Whqirtd98880udpMmTcoGDRrUrf1BBx2U7brrrq31FStWZOecc042fPjwbODAgdkBBxyQ/fKXv8wOOuig7KCDDurS9p577sl22223rF+/ftm2226bXXfdddkXvvCFbPPNN+/Wz+LFi7Ozzz4723rrrbO+fftmW265ZbbffvtlX/va19jty7dn4cKF2THHHJNtttlm2eDBg7OTTz45+8tf/oLuC/uq4V/+8pfZP/zDP2SDBg3KBgwYkO2zzz7Z/fff362vK664Ihs5cmTWq1evDACyX/ziF2xsEr8+V2tnWZa999572cCBA7MpU6ZkN910k6ptHXXDDTdk/fr1y1588cXC+uD2teSzon47lDS/FUqS3xAXF/Wdv++++7Ldd9+9i1/7qmVK0t+Lz3f7kUceaV3d//LLL3erl+5Tart/+tOfZnvssUc2YMCAbIcddshuvfVWdLtdx6P3338/O/fcc7Pdd9896+joyAYMGJDtuOOO2VVXXZW9++674u1NopX+lapEffDBB7DHHnvA1ltvDY888kgUn1OnToWrr74a3nzzzdKGQuui448/Hn7yk5/Ayy+/LJqXr5vee+89+M1vfgMLFiyASy+9FK699lq45JJLqg6r1iriN5SUVEelYe0Cdc4558Dhhx8OW221FSxbtgy+853vwO9+9zu4+eabqw6tR+i4446DP/7xj40EMwDAI488Ap/+9Kehs7MTvvzlLycwI0q/oaRNVQnOBWr16tVwySWXwJtvvgl9+/aFvfbaC37605/CYYcdVnVoPULHHHOM8/apOuv444+HNHDFK/2GkjZVpWHtpKSkpKSkmqnSW6m+/e1vw+jRo6F///4wbtw4+OUvf1llOElJSUlJSbVQZXC+8847YfLkyXDllVfCr3/9a/jEJz4BRx11FLz22mtVhZSUlJSUlFQLVTasPWHCBNhrr71gxowZrbKdd94Zjj/+eJg+fXoVISUlJSUlJdVClVwQtm7dOli4cCFcfvnlXcqPOOKI1sP/Ta1du7bLY+c2btwIf/vb32DYsGHBD7NISkpKSipfWZbB6tWrYeTIkd0ethJT77//fpenzPmqX79+3f57oUhVAue//vWvsGHDhm4PsB8xYgT6fNvp06fD1VdfXVZ4SUlJSUklacmSJeKnxmn1/vvvw+jRo6P8GUdnZycsXrxYBOjtt9++y78Z5jrvvPPgW9/6lqi/Sm+lsrPeLMvQTPiKK66AKVOmtNZXrlwJ2267Lbz66qutx0dmH/43dZdlex3gw6zb7M+0ocoo/1Q7uw+Xf6pPzt58N/tz9cn5od5dvnPZcVB2XCzcckgdVSa1wbYtRDFnk2KOHlEZjLQP245bl9Zpljn/AP9v+1xtXTa+72YcmjZYHdfObGtvM9WW6peyofpw2efLq1atgu222458BHAMrVu3DpYtWwavvfYadHR0ePtZtWoVbLvttrBu3ToRnBcsWNDlsagvvPACHH744XDiiSeK+6wEzltssQX07t2729nM8uXL0b+Da29v7/awd4AP/66vo6MjCpg1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ZZddYMmSJYUNiTRdq1atglGjRqV95FDaTzKl/SRT2k8yZVkGq1evhpEjRxbWR//+/WHx4sWwbt26YF9Z1v1aFSxrNmXbYz4oNRLOvXr1gq233hoAADo6OtIPwKG0j2RK+0mmtJ9kSvvJraIyZlP9+/eH/v37F96PqS222AJ69+7dLUtevnx5t2yaUqNvpUpKSkpKSqqb+vXrB+PGjYO5c+d2KZ87dy7st99+Ih+NzJyTkpKSkpLqrClTpsDpp58O48ePh3333Rduu+02eO211+Dcc88VtW8snNvb2+Gqq65yjvlvykr7SKa0n2RK+0mmtJ+SAAA+85nPwFtvvQXXXHMNLF26FMaOHQs//elPYbvtthO1b+R9zklJSUlJST1Zac45KSkpKSmpZkpwTkpKSkpKqpkSnJOSkpKSkmqmBOekpKSkpKSaKcE5KSkpKSmpZmoknEP+I7Ppmj59Ouy9994wePBgGD58OBx//PHw0ksvdbHJsgymTp0KI0eOhAEDBsDBBx8MixYt6mKzdu1auPDCC2GLLbaAQYMGwbHHHguvv/56mZtSqqZPnw5tbW0wefLkVlnaTx/qjTfegNNOOw2GDRsGAwcOhD322AMWLlzYqk/7CWD9+vXwla98BUaPHg0DBgyAHXbYAa655ppuf26zqe+npIjKGqY5c+Zkffv2zb773e9mL774YnbRRRdlgwYNyl599dWqQytFRx55ZDZz5szshRdeyJ577rns6KOPzrbddtvsnXfeadlcd9112eDBg7O77rore/7557PPfOYz2VZbbZWtWrWqZXPuuedmW2+9dTZ37tzs2WefzQ455JDsYx/7WLZ+/foqNqtQPfPMM9n222+f7b777tlFF13UKk/7Kcv+9re/Zdttt1125plnZk8//XS2ePHibN68edkrr7zSskn7Kcu+9rWvZcOGDcseeOCBbPHixdmPfvSjbLPNNstuuummlk3aT0kx1Tg4f/zjH8/OPffcLmU77bRTdvnll1cUUbVavnx5BgDZ/PnzsyzLso0bN2adnZ3Zdddd17J5//33syFDhmTf+c53sizLsrfffjvr27dvNmfOnJbNG2+8kfXq1St76KGHyt2AgrV69epszJgx2dy5c7ODDjqoBee0nz7Ul770peyAAw4g69N++lBHH310dvbZZ3cpO+GEE7LTTjsty7K0n5Liq1HD2vl/ZB5xxBFdyjX/kdnTtHLlSgAAGDp0KAAALF68GJYtW9ZlH7W3t8NBBx3U2kcLFy6EDz74oIvNyJEjYezYsT1uP55//vlw9NFHw2GHHdalPO2nD3XffffB+PHj4cQTT4Thw4fDnnvuCd/97ndb9Wk/fagDDjgAfvazn8HLL78MAAC/+c1v4PHHH4dPfepTAJD2U1J8NerxnTH+I7MnKcsymDJlChxwwAEwduxYAIDWfsD20auvvtqy6devH2y++ebdbHrSfpwzZw48++yzsGDBgm51aT99qD/96U8wY8YMmDJlCnz5y1+GZ555Br7whS9Ae3s7nHHGGWk//f/60pe+BCtXroSddtoJevfuDRs2bIBrr70WTj75ZABI36ek+GoUnHOF/EdmT9IFF1wAv/3tb+Hxxx/vVuezj3rSflyyZAlcdNFF8Mgjj7B/F7ep76eNGzfC+PHjYdq0aQAAsOeee8KiRYtgxowZcMYZZ7TsNvX9dOedd8Ls2bPhjjvugF133RWee+45mDx5MowcORImTZrUstvU91NSPDVqWDvGf2T2FF144YVw3333wS9+8QvYZpttWuWdnZ0AAOw+6uzshHXr1sGKFStIm6Zr4cKFsHz5chg3bhz06dMH+vTpA/Pnz4dvfvOb0KdPn9Z2bur7aauttoJddtmlS9nOO+8Mr732GgCk71OuSy+9FC6//HL47Gc/C7vtthucfvrp8MUvfhGmT58OAGk/JcVXo+Ac4z8ym64sy+CCCy6Au+++G37+85/D6NGju9SPHj0aOjs7u+yjdevWwfz581v7aNy4cdC3b98uNkuXLoUXXnihx+zHQw89FJ5//nl47rnnWq/x48fDqaeeCs899xzssMMOaT8BwP7779/tVryXX3659c856fv0od577z3o1avr4bJ3796tW6nSfkqKroouRPNWfivV7bffnr344ovZ5MmTs0GDBmV//vOfqw6tFH3+85/PhgwZkj366KPZ0qVLW6/33nuvZXPddddlQ4YMye6+++7s+eefz04++WT0lo5tttkmmzdvXvbss89m//AP/9Djb+kwr9bOsrSfsuzD28z69OmTXXvttdkf/vCH7Ic//GE2cODAbPbs2S2btJ+ybNKkSdnWW2/dupXq7rvvzrbYYovssssua9mk/ZQUU42Dc5Zl2be+9a1su+22y/r165fttdderduINgUBAPqaOXNmy2bjxo3ZVVddlXV2dmbt7e3ZgQcemD3//PNd/KxZsya74IILsqFDh2YDBgzIJk6cmL322mslb025suGc9tOHuv/++7OxY8dm7e3t2U477ZTddtttXerTfsqyVatWZRdddFG27bbbZv3798922GGH7Morr8zWrl3bskn7KSmm0v85JyUlJSUl1UyNmnNOSkpKSkraFJTgnJSUlJSUVDMlOCclJSUlJdVMCc5JSUlJSUk1U4JzUlJSUlJSzZTgnJSUlJSUVDMlOCclJSUlJdVMCc5JSUlJSUk1U4JzUlJSUlJSzZTgnJSUlJSUVDMlOCclJSUlJdVM/x9/CGwf8kJFEwAAAABJRU5ErkJggg=="/>

위 그래프를 보자. 계산된 값이 들어 있는 2차원 배열로부터 그래프 이미지를 생성하기 위해 matplotlib의 imshow 함수를 사용


### 4.3.1 배열 연산으로 조건절 표현하기


numpy.where 함수는 x if 조건 else y 같은 삼항식의 벡터화된 버전<br>

다음과 같은 불리언 배열 하나와 값이 들어 있는 두 개의 배열이 있다고 하자



```python
xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
```


```python
yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
```


```python
cond = np.array([True, False, True, True, False])
```

cond의 값이 True일 때는 xarr의 값을 취하고 아니면 yarr의 값을 취하고 싶다면 리스트 표기법(list comprehension)을 이용해서 다음처럼 작성 가능



```python
result = [(x if c else y)
         for x,y,c in zip(xarr, yarr, cond)]
```


```python
result
```

<pre>
[1.1, 2.2, 1.3, 1.4, 2.5]
</pre>
#### np.where


이 방법에는 몇 가지 문제가 있는데, 순수 파이썬으로 수행되기 때문에 큰 배열을 빠르게 처리 못함<br>

또한 다차원 배열에서는 사용 불가<br>

np.where을 사용하면 아주 간결히 작성 가능



```python
result = np.where(cond, xarr, yarr)
```


```python
result
```

<pre>
array([1.1, 2.2, 1.3, 1.4, 2.5])
</pre>
np.where의 두 번째와 세 번째 인자는 배열이 아니어도 상관없다. 둘 중 하나 혹은 둘 다 스칼라값이어도 동작함.<br>

데이터 분석에서 일반적인 where의 사용은 다른 배열에 기반한 새로운 배열 생성<br>

임의로 생성된 데이터가 들어 있는 행렬이 있고 양수는 모두 2로, 음수는 모두 -2로 바꾸려면 np.where을 사용해 쉽게 처리 가능



```python
arr = np.random.randn(4,4)
```


```python
arr
```

<pre>
array([[ 0.20092124, -1.596208  ,  1.12290132,  1.18443979],
       [ 0.67685056, -0.11174729, -2.44541904,  0.76639396],
       [ 0.24166897, -0.76020944, -0.3366009 , -0.07469957],
       [-0.53976708, -0.9921677 , -1.20365175, -0.97638368]])
</pre>

```python
arr > 0
```

<pre>
array([[ True, False,  True,  True],
       [ True, False, False,  True],
       [ True, False, False, False],
       [False, False, False, False]])
</pre>

```python
np.where(arr > 0, 2, -2)
```

<pre>
array([[ 2, -2,  2,  2],
       [ 2, -2, -2,  2],
       [ 2, -2, -2, -2],
       [-2, -2, -2, -2]])
</pre>

```python
np.where를 사용할 때 스칼라값과 배열을 조합 가능.<br>
예를 들어 arr의 모든 양수를 2로 바꿀 수 있음
```


```python
np.where(arr > 0, 2, arr) # 양수인 경우에만 2를 대입
```

<pre>
array([[ 2.        , -1.596208  ,  2.        ,  2.        ],
       [ 2.        , -0.11174729, -2.44541904,  2.        ],
       [ 2.        , -0.76020944, -0.3366009 , -0.07469957],
       [-0.53976708, -0.9921677 , -1.20365175, -0.97638368]])
</pre>
np.where로 넘기는 배열은 그냥 크기만 같은 배열이거나 스칼라값이 될 수 있다


### 4.3.2 수학 메서드와 통계 메서드


배열 전체 혹은 배열에서 한 축을 따르는 자료에 대한 통계를 계산하는 수학 함수는 배열 메서드로 사용 가능<br>

전체의 합(sum)이나 평균(mean), 표준편차(std)는 NumPy의 최상위 함수를 이용하거나 배열의 인스턴스 메서드를 이용해 구할 수 있음


임의의 정규 분포 데이터를 생성하고 집계해보자



```python
arr = np.random.randn(5,4)
```


```python
arr
```

<pre>
array([[-0.34181482,  0.17551945,  0.85225569, -0.5851887 ],
       [ 0.03793518,  1.52122583,  2.23812257,  0.96544397],
       [-1.38938657, -0.30691579,  0.80399053, -0.01765946],
       [-0.60118077, -0.40301646, -1.83844415,  0.39382908],
       [ 0.44025297, -0.56450256, -0.5061319 , -0.87029518]])
</pre>

```python
arr.mean()
```

<pre>
0.0002019458750383063
</pre>

```python
np.mean(arr)
```

<pre>
0.0002019458750383063
</pre>

```python
arr.sum()
```

<pre>
0.004038917500766126
</pre>
mean이나 sum 같은 함수는 선택적으로 axis 인자를 받아서 해당 axis에 대한 통계를 계산하고 <br>

한 차수 낮은 배열을 반환



```python
arr.mean(axis=1)
```

<pre>
array([ 0.02519291,  1.19068189, -0.22749282, -0.61220308, -0.37516917])
</pre>

```python
arr.sum(axis = 0)
```

<pre>
array([ 0.57967368, -3.46033243, -2.86277037,  0.89975051])
</pre>
여기서 arr.sum(0)은 로우의 합을 구하라는 의미이며, arr.mean(1)은 모든 컬럼에서 평균을 구하라는 의미


#### cumsum, cumprod


cumsum과 cumprod 메서드는 중간 계산값을 담고 있는 배열을 반환



```python
arr = np.array([0,1,2,3,4,5,6,7])
```


```python
arr.cumsum()
```

<pre>
array([ 0,  1,  3,  6, 10, 15, 21, 28])
</pre>
다차원 배열에서 cumsum 같은 누산 함수는 같은 크기의 배열을 반환<br>

하지만 축을 지정하여 부분적으로 계산하면 낮은 차수의 슬라이스를 반환



```python
arr = np.array([[0,1,2],[3,4,5],[6,7,8]])
```


```python
arr
```

<pre>
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
</pre>

```python
arr.cumsum(axis=0)
```

<pre>
array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]])
</pre>

```python
arr.cumprod(axis =1) #cumprod는 누적곱을 의미
```

<pre>
array([[  0,   0,   0],
       [  3,  12,  60],
       [  6,  42, 336]])
</pre>
- 기본 배열 통계 메서드


#### sum


배열 전체 혹은 특정 축에 대한 모든 원소의 합을 계산.<br>

크기가 0인 배열에 대한 sum 결과는 0



```python
a = np.array([[1,0,3],
             [2,5,4],
             [3,6,7]])
```


```python
a
```

<pre>
array([[1, 0, 3],
       [2, 5, 4],
       [3, 6, 7]])
</pre>

```python
np.sum(a)
```

<pre>
31
</pre>

```python
np.sum(a, axis=0)
```

<pre>
array([ 6, 11, 14])
</pre>

```python
np.sum(a, axis=1)
```

<pre>
array([ 4, 11, 16])
</pre>
#### mean


산술 평균을 구함. 크기가 0인 배열에 대한 mean 결과는 NaN



```python
data = np.array([[0., 0., 0., 0.], [1., 1., 1., 1.], [2., 2., 2., 2.],[3., 3., 3., 3.], [4., 4., 4., 4.]]) 
```


```python
data
```

<pre>
array([[0., 0., 0., 0.],
       [1., 1., 1., 1.],
       [2., 2., 2., 2.],
       [3., 3., 3., 3.],
       [4., 4., 4., 4.]])
</pre>

```python
data.mean(1) # row's mean
```

<pre>
array([0., 1., 2., 3., 4.])
</pre>

```python
data.mean(0) # column's mean
```

<pre>
array([2., 2., 2., 2.])
</pre>
#### std, var


각각 표준편차(std)와 분산(var)을 구함.<br>

선택적으로 자유도를 줄 수 있으며 분모의 기본값은 n



```python
data = np.array([ 0, 2, 4, 6, 8, 10, 8, 6, 4, 2]) 
```


```python
data
```

<pre>
array([ 0,  2,  4,  6,  8, 10,  8,  6,  4,  2])
</pre>

```python
data.std()
```

<pre>
3.0
</pre>

```python
data.var()
```

<pre>
9.0
</pre>
#### min, max


최솟값과 최댓값



```python
data.min()
```

<pre>
0
</pre>

```python
data.max()
```

<pre>
10
</pre>
#### argmin, argmax

최소 원소의 색인값과 최대 원소의 색인값



```python
data.argmin()
```

<pre>
0
</pre>

```python
data.argmax()
```

<pre>
5
</pre>
#### cumsum


각 원소의 누적합



```python
data
```

<pre>
array([ 0,  2,  4,  6,  8, 10,  8,  6,  4,  2])
</pre>

```python
data.cumsum()
```

<pre>
array([ 0,  2,  6, 12, 20, 30, 38, 44, 48, 50])
</pre>
#### cumprod()


각 원소의 누적곱



```python
data.cumprod()
```

<pre>
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
</pre>
### 4.3.3 불리언 배열을 위한 메서드


이전 메서드의 불리언값을 1(True) 또는 0(False)으로 강제 가능<br>

따라서 sum 메서드를 실행하면 불리언 배열에서 True인 원소의 개수 셀 수 있음



```python
arr = np.random.randn(100)
arr
```

<pre>
array([-0.03587758, -1.35590754, -0.47401495, -0.88732075,  1.10266951,
       -0.12366378, -0.37149165,  0.86813614,  0.06238285, -0.99231921,
       -0.24826807, -0.70913053,  0.88737051, -0.49059356,  1.50148454,
        0.68462649, -0.73643782, -0.63976133, -2.08664242, -0.10043489,
        0.86257443, -0.17582709, -0.20957397,  0.80758678,  2.09885169,
        0.74412448, -0.93818187,  0.42135391,  0.03292931,  0.81788745,
        0.56243759,  0.47034342, -0.60046063,  0.62286081, -0.77125843,
       -0.21456675,  0.2959778 ,  0.35804411, -0.16378894,  0.43770622,
       -0.33541624, -0.73206369,  1.46734599,  0.79178948, -0.33855794,
        0.30492919,  0.42062676,  0.82089437,  1.15622992,  2.13510898,
        1.23962872, -0.28347852,  1.68561465,  0.0078279 ,  1.20234306,
       -0.51357103,  0.03549542, -0.24433534,  0.59614283,  0.8423261 ,
        1.31377687, -0.38814536, -1.01374612,  0.55604486, -0.6584057 ,
        1.30873406,  0.82719936, -1.15070613,  0.1612895 ,  0.80937023,
       -3.46199344,  0.62577254, -0.69435204, -2.49615497,  0.82950449,
        0.3425465 , -0.67389768, -0.79311803,  0.19495854, -1.77154684,
        0.35195905, -0.07646966, -1.24393615,  0.82586427, -2.34676386,
       -1.24687385,  0.03953933, -1.06483426,  0.43299226,  0.49738022,
       -0.75260233,  1.18293427,  2.34282214,  0.62875144,  0.94603176,
       -1.06058666,  0.40478715,  0.88030263, -1.65632224, -0.62308196])
</pre>

```python
(arr>0).sum() # 양수인 원소의 개수
```

<pre>
54
</pre>
#### any, all


any와 all 메서드는 불리언 배열에 특히 유용<br>

any 메서드는 하나 이상의 값이 True인지 검사하고, <br>

all 메서드는 모든 원소가 True인지 검사



```python
bools = np.array([False, False, True, False])
```


```python
bools.any()
```

<pre>
True
</pre>

```python
bools.all()
```

<pre>
False
</pre>
이들 메서드는 불리언 배열이 아니어도 동작<br>

0이 아닌 원소는 모두 True로 간주


### 4.3.4 정렬


#### sort


파이썬의 내장 리스트형처럼 NumPy 배열 역시 sort 메서드를 이용해 정렬 가능



```python
arr = np.random.randn(6)
```


```python
arr
```

<pre>
array([ 0.2033572 , -0.72119612, -0.29433788,  1.62252437, -1.19857347,
        0.98699745])
</pre>

```python
arr.sort()
```


```python
arr
```

<pre>
array([-1.19857347, -0.72119612, -0.29433788,  0.2033572 ,  0.98699745,
        1.62252437])
</pre>
다차원 배열의 정렬은 sort 메서드에 넘긴 축의 값에 따라 1차원 부분을 정렬



```python
arr = np.random.randn(5,3)
```


```python
arr
```

<pre>
array([[-0.47979148, -2.5956427 , -1.08986763],
       [-0.37651548, -0.26069298, -0.20533591],
       [-0.52769218,  0.74824239, -0.61137292],
       [ 0.59339952,  0.44786756,  0.02271568],
       [-0.60536726, -1.05801076,  0.19521496]])
</pre>

```python
arr.sort(1) #열끼리 정렬
```


```python
arr
```

<pre>
array([[-2.5956427 , -1.08986763, -0.47979148],
       [-0.37651548, -0.26069298, -0.20533591],
       [-0.61137292, -0.52769218,  0.74824239],
       [ 0.02271568,  0.44786756,  0.59339952],
       [-1.05801076, -0.60536726,  0.19521496]])
</pre>
np.sort 메서드는 배열을 직접 변경하지 않고 정렬된 결과를 가지고 있는 복사본을 반환<br>

배열의 분위수를 구하는 쉽고 빠른 방법은 우선 배열을 정렬한 후 특정 분위의 값을 선택하는 것



```python
large_arr = np.random.randn(1000)
```


```python
large_arr.sort()
```


```python
large_arr[int(0.05*len(large_arr))] # 5% 분위수
```

<pre>
-1.5620670823151683
</pre>
### 4.3.5 집합 관련 함수


#### unique


NumPy는 1차원 ndarray를 위한 몇 가지 기본적인 집합 연산 제공<br>

***np.unique*** : 배열 내에서 중복된 원소를 제거하고 남은 원소를 정렬된 형태로 반환하는 함수



```python
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
```


```python
np.unique(names)
```

<pre>
array(['Bob', 'Joe', 'Will'], dtype='<U4')
</pre>

```python
ints = np.array([3,3,3,2,2,1,1,4,4])
```


```python
np.unique(ints)
```

<pre>
array([1, 2, 3, 4])
</pre>
np.unique를 순수 파이썬으로만 구현하면 다음과 같다



```python
sorted(set(names))
```

<pre>
['Bob', 'Joe', 'Will']
</pre>
#### np.in1d


nd.in1d 함수는 두 개의 배열을 인자로 받아서 첫 번째 배열의 원소가 두 번째 배열의 원소를 포함하는지 나타내는 불리언 배열 반환



```python
values = np.array([6,0,0,3,2,5,6])
```


```python
np.in1d(values, [2,3,6])
```

<pre>
array([ True, False, False,  True,  True, False,  True])
</pre>
- 배열 집합 연산


#### unique(x)


배열 X에서 중복된 원소를 제거한 뒤 정렬해 반환<br>

문자열이 포함된 경우, 전부 문자열로 변환된 결과가 나타나게 되며<br>

이 때, 정수형 3과 문자열 '3'은 같은 값으로 취급됨



```python
np.unique([[1,3,5],
          [2,2,3]])
```

<pre>
array([1, 2, 3, 5])
</pre>

```python
np.unique(['a','b',3,5,'a','3'])
```

<pre>
array(['3', '5', 'a', 'b'], dtype='<U11')
</pre>
#### intersect1d(x,y)


두 개의 배열 x,y의 교집합을 정렬해 반환



```python
x = np.array([1,2,3,4])
```


```python
y = np.array([3,4,5,6])
```


```python
np.intersect1d(x,y)
```

<pre>
array([3, 4])
</pre>
#### union1d(x,y)


두 배열의 합집합 반환



```python
x = np.array([1,2,3,4])
```


```python
y = np.array([3,4,5,6])
```


```python
np.union1d(x,y)
```

<pre>
array([1, 2, 3, 4, 5, 6])
</pre>
#### in1d(x,y)


x의 원소가 y의 원소에 포함되는지 나타내는 불리언 배열 반환



```python
x = np.array([1,2,3,4,5,6])
```


```python
y = np.array([2,4])
```


```python
np.in1d(x,y)
```

<pre>
array([False,  True, False,  True, False, False])
</pre>
#### setdiff1d(x,y)


x와 y의 차집합 반환



```python
x = np.array([1,2,3,4])
```


```python
y = np.array([3,4,5,6])
```


```python
np.setdiff1d(x,y)
```

<pre>
array([1, 2])
</pre>
#### setxor1d(x,y)


두 배열 x,y의 합집합에서 교집합을 뺀 대칭차집합 반환



```python
x = np.array([1,2,3,4])
```


```python
y = np.array([3,4,5,6])
```


```python
np.setxor1d(x,y)
```

<pre>
array([1, 2, 5, 6])
</pre>

```python
#171부터
```

## 4.4 배열 데이터의 파일 입출력


### np.save, np.load


배열 데이터를 효과적으로 디스크에 저장하고 불러오기 위한 함수<br>

배열은 기본적으로 압축되지 않은 원시(가공되지 않은) 바이너리 형식의 .npy 파일로 저장



```python
arr = np.arange(10)
```


```python
np.save('some_array', arr)
```

저장되는 파일 경로가 .npy로 끝나지 않으면 자동적으로 확장자 추가<br>

이렇게 저장된 배열은 np.load를 이용해 불러오기 가능



```python
np.load('some_array.npy')
```

<pre>
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</pre>
### np.savez


np.savez 함수를 이용하면 여러 개의 배열을 압축된 형식으로 저장 가능<br>

저장하려는 배열을 키워드 인자 형태로 전달



```python
np.savez('array_archive.npz', a = arr, b = arr)
```

npz 파일을 불러올 때는 각각의 배열을 필요할 때 불러올 수 있도록 사전 형식의 객체에 저장



```python
arch = np.load('array_archive.npz')
```


```python
arch['b']
```

<pre>
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</pre>
### np.savez_compressed


압축이 잘되는 형식의 데이터라면 대신 numpy.savez_compressed 사용



```python
np.savez_compressed('arrays_compressed.npz', a= arr, b = arr)
```

## 4.5 선형대수


### dot, np.dot


행렬의 곱셈, 분할, 행렬식 그리고 정사각 행렬 수학 같은 선형대수는 배열을 다루는 라이브러리에서 중요한 부분<br>

매트랩 같은 언어와 다르게 두 개의 2차원 배열을 * 연산자로 곱하면 행렬 곱셈이 아니라 대응하는 각각의 원소의 곱을 계산<br>

행렬 곱셈은 배열 메서드이자 numpy 네임스페이스 안에 있는 dot 함수를 이용해 계산



```python
x = np.array([[1.,2.,3.], [4.,5.,6.]])
```


```python
y = np.array([[6.,23.], [-1,7], [8,9]])
```


```python
x
```

<pre>
array([[1., 2., 3.],
       [4., 5., 6.]])
</pre>

```python
y
```

<pre>
array([[ 6., 23.],
       [-1.,  7.],
       [ 8.,  9.]])
</pre>

```python
x.dot(y)
```

<pre>
array([[ 28.,  64.],
       [ 67., 181.]])
</pre>
x.dot(y)는 np.dot(x,y)와 동일



```python
np.dot(x,y)
```

<pre>
array([[ 28.,  64.],
       [ 67., 181.]])
</pre>
2차원 배열과 곱셈이 가능한 크기의 1차원 배열 간의 행렬 곱셈 결과는 1차원 배열



```python
np.dot(x, np.ones(3))
```

<pre>
array([ 6., 15.])
</pre>
파이썬 3.5부터 사용 가능한 @ 기호는 행렬 곱셈을 수행하는 연산자



```python
x @ np.ones(3)
```

<pre>
array([ 6., 15.])
</pre>
### numpy.linalg

정리안함p.173


### 자주 사용하는 numpy.linalg 함수

174 참고


## 4.6 난수 생성


### random.normal


numpy.random 모듈은 파이썬 내장 random 함수를 보강해 다양한 종류의 확률분포로부터 효과적으로 표본값을 생성하는데 주로 사용<br>

예를 들어 normal을 사용해 표준정규분포로부터 4x4 크기의 표본 생성 가능



```python
samples = np.random.normal(size = (4,4))
```


```python
samples
```

<pre>
array([[-0.95052769,  1.33373602, -0.33995108,  0.62902117],
       [-1.29410197,  1.14071729,  0.94892349, -0.91026362],
       [-1.17348302, -1.12508338, -0.2518712 , -0.01107124],
       [-2.4212388 ,  0.97418803, -0.27271252,  0.52624489]])
</pre>
이에 비해 파이썬 내장 random 모듈은 한 번에 하나의 값만 생성<br>

다음 성능 비교에서 알 수 있듯이 numpy.random은 매우 큰 표본을 생성하는데 파이썬 내장 모듈보다 수십 배 이상 빠름



```python
from random import normalvariate
```


```python
N = 1000000
```


```python
%timeit samples = [normalvariate(0,1) for _ in range(N)]
```

<pre>
587 ms ± 894 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)
</pre>

```python
%timeit np.random.normal(size=N)
```

<pre>
18.3 ms ± 56.1 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</pre>
이를 엄밀하게는 ***유사 난수***라고 부르는데, 난수 생성기의 ***시드값***에 따라 정해진 난수를 알고리즘으로 생성하기 때문<bR>

NumPy 난수 생성기의 시드값은 np.random.seed를 이용해 변경 가능



```python
np.random.seed(1234)
```

### random.RandomState


numpy.random에서 제공하는 데이터를 생성할 수 있는 함수들은 전역 난수 시드값 이용<bR>

numpy.random.RandonState을 이용해 다른 난수 생성기로부터 격리된 난수 생성기를 만들 수 있다



```python
rng = np.random.RandomState(1234)
```


```python
rng.randn(10)
```

<pre>
array([ 0.47143516, -1.19097569,  1.43270697, -0.3126519 , -0.72058873,
        0.88716294,  0.85958841, -0.6365235 ,  0.01569637, -2.24268495])
</pre>
### 일부 numpy.random 함수


#### seed


난수 생성기의 시드 지정


#### permutation

순서를 임의로 바꾸거나 임의의 순열 반환



```python
np.random.permutation(10)
```

<pre>
array([7, 2, 9, 1, 0, 8, 4, 5, 6, 3])
</pre>

```python
np.random.permutation([1,4,9,12,15])
```

<pre>
array([ 1, 15, 12,  9,  4])
</pre>

```python
arr = np.arange(9).reshape((3,3))
arr
```

<pre>
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
</pre>

```python
np.random.permutation(arr)
```

<pre>
array([[3, 4, 5],
       [0, 1, 2],
       [6, 7, 8]])
</pre>
#### shuffle


리스트나 배열의 순서를 뒤섞음



```python
arr = np.arange(10)
arr
```

<pre>
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</pre>

```python
np.random.shuffle(arr)
```


```python
arr
```

<pre>
array([8, 1, 7, 6, 9, 5, 4, 3, 0, 2])
</pre>

```python
arr = np.arange(9).reshape((3,3))
arr
```

<pre>
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
</pre>

```python
np.random.shuffle(arr)
```


```python
arr
```

<pre>
array([[6, 7, 8],
       [3, 4, 5],
       [0, 1, 2]])
</pre>
#### rand


균등분포에서 표본 추출



```python
np.random.rand(3,2)
```

<pre>
array([[0.07538124, 0.36882401],
       [0.9331401 , 0.65137814],
       [0.39720258, 0.78873014]])
</pre>
#### randint


주어진 최소/최대 범위 안에서 임의의 난수 추출



```python
np.random.randint(2, size=10)
```

<pre>
array([0, 1, 1, 0, 0, 1, 0, 0, 1, 1])
</pre>

```python
np.random.randint(1, size=10)
```

<pre>
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
</pre>

```python
np.random.randint(5, size=(2,4))
```

<pre>
array([[4, 0, 4, 1],
       [1, 4, 1, 4]])
</pre>

```python
np.random.randint(1, [3,5,10])
```

<pre>
array([2, 1, 9])
</pre>
#### randn


표준편차가 1이고 평균값이 0인 정규분포(매트랩과 같은 방식)에서 표본 추출



```python
np.random.randn()
```

<pre>
0.12471295376821585
</pre>

```python
np.random.randn(2,4)
```

<pre>
array([[-0.32279481,  0.84167471,  2.39096052,  0.07619959],
       [-0.56644593,  0.03614194, -2.0749776 ,  0.2477922 ]])
</pre>
#### binomial


이항분포에서 표본 추출


#### normal


정규분포(가우시안)에서 표본 추출


#### beta


베타분포에서 표본 추출


#### chisquare

카이제곱분포에서 표본 추출


#### gamma 

감마분포에서 표본 추출


#### uniform


균등 [0,1) 분포에서 표본 추출


p176 계단오르기 예제부터



```python
```
